<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zbigboom.github.io</id>
    <title>ZBigBoom</title>
    <updated>2020-12-03T14:46:17.410Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zbigboom.github.io"/>
    <link rel="self" href="https://zbigboom.github.io/atom.xml"/>
    <subtitle>我的世界</subtitle>
    <logo>https://zbigboom.github.io/images/avatar.png</logo>
    <icon>https://zbigboom.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, ZBigBoom</rights>
    <entry>
        <title type="html"><![CDATA[[微机]第二章8086微处理器]]></title>
        <id>https://zbigboom.github.io/post/4/</id>
        <link href="https://zbigboom.github.io/post/4/">
        </link>
        <updated>2020-12-02T13:20:07.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="8086cpu基本结构">8086CPU基本结构</h3>
<p>8086由两个独立的处理部件组成：执行部件EU和总线接口部件BIU。<br>
①执行机构EU：包括8个16位寄存器（通用寄存器AX、BX、CX、DX；指针寄存器SP、BP；变址寄存器SI、DI）算数逻辑部件ALU、标志寄存器FR、暂存寄存器和EU控制系统。<br>
②总线接口部件BIU：由4个段寄存器（CS、SS、DS、ES）指令指针IP、内部通信寄存器、指令队列、总线控制逻辑和地址加法器组成。</p>
<h3 id="特点">特点</h3>
<p>①取指令与执行指令重叠并行（指令流水线）。<br>
②段寄存器和储存器分段：8086有四个段寄存器，代码段寄存器CS、数据段寄存器DS、堆栈段寄存器SS、附加数据段寄存器ES。<br>
每个段的物理长度是64K。<br>
基于存储器的分段结构，在涉及储存器的地址时，必须分清是物理地址还是逻辑地址。CPU访问存储器时地址总线送出的是物理地址，编写程序时则采用逻辑地址，逻辑地址由短地址和偏移量组成。<br>
物理地址计算公式：</p>
<center>物理地址=段地址*16+偏移量</center>
]]></summary>
        <content type="html"><![CDATA[<h3 id="8086cpu基本结构">8086CPU基本结构</h3>
<p>8086由两个独立的处理部件组成：执行部件EU和总线接口部件BIU。<br>
①执行机构EU：包括8个16位寄存器（通用寄存器AX、BX、CX、DX；指针寄存器SP、BP；变址寄存器SI、DI）算数逻辑部件ALU、标志寄存器FR、暂存寄存器和EU控制系统。<br>
②总线接口部件BIU：由4个段寄存器（CS、SS、DS、ES）指令指针IP、内部通信寄存器、指令队列、总线控制逻辑和地址加法器组成。</p>
<h3 id="特点">特点</h3>
<p>①取指令与执行指令重叠并行（指令流水线）。<br>
②段寄存器和储存器分段：8086有四个段寄存器，代码段寄存器CS、数据段寄存器DS、堆栈段寄存器SS、附加数据段寄存器ES。<br>
每个段的物理长度是64K。<br>
基于存储器的分段结构，在涉及储存器的地址时，必须分清是物理地址还是逻辑地址。CPU访问存储器时地址总线送出的是物理地址，编写程序时则采用逻辑地址，逻辑地址由短地址和偏移量组成。<br>
物理地址计算公式：</p>
<center>物理地址=段地址*16+偏移量</center>
<!-- more -->
<h3 id="寄存器配置">寄存器配置</h3>
<p>Ⅰ通用寄存器：8086有8个16位通用寄存器，8个通用寄存器分两组。<br>
第一组：AX、BX、CX、DX，他们又可以分成两个8位寄存器，当处理字节指令时，用8位寄存器，处理字指令时，用16位寄存器。<br>
特殊用法：BX寄存器在计算地址时用作基址寄存器；CX寄存器在操作指令中用作计数器；DX寄存器在某些I/O操作期间用来保存I/O端口地址。<br>
第二组：堆栈指针SP、基地址指针BP、源变址寄存器SI、目的变址寄存器DI，4个16位寄存器。<br>
这组寄存器的目的是：①算短指令代码的长度②在程序运行过程中，允许指令访问这样的存储单元，他们在段内的偏移量正是前面指令的计算结果③用于寄存偏移量，与段寄存器内容相加获得物理地址。<br>
Ⅱ段寄存器：见特点中段寄存器。<br>
Ⅲ指令指针IP：指令指针是一个16位寄存器，功能与程序计数器PC类似。IP总是包含下一条指令在当前代码段的偏移量（人话：IP在这个代码段内保存与下一条指令的偏移量）。</p>
<center>下一条指令的物理地址=CS*16+IP或CS*10H+IP</center>
<!-- more -->
<p>Ⅳ状态标志寄存器FR：FR标志寄存器是16位寄存器，但只使用其中9位。<br>
①CF进位标志：当进行加减运算时，若最高位产生进位或借位时CF=1。<br>
②PF奇偶标志：若运算结果低八位中含有1的个数为偶数时PF=1，此标志一般用来检测数据传输中是否发生错误。<br>
③AF辅助进位标志：低四位向高四位有进位或借位，则AF=1，此标志用于校正BCD编码的十进制算数指令操作。<br>
④ZF零标志：若运算结果为0，则ZF=1。<br>
⑤SF符号标志：对于带符号数，若运算结果最高位为1为负数则SF=1。<br>
⑥OF溢出标志：当进行带符号数补码运算时，结果超出了机器所能表示的数值范围，产生了“溢出”则OF=1。<br>
⑦IF中断允许标志：该标志用于允许或禁止CPU响应外部中断，由程序控制。若IF=1则CPU可以响应外部可屏蔽中断的中断请求。<br>
⑧DF方向标志：用于串操作，由程序控制，若DF=1，表示执行串操作时，从高地址开始向低地址逐个处理，即串地址自动减量。<br>
⑨TF陷阱标志：该标志是为了调试程序而设置的。若TF=1，表示CPU以单步方式执行程序，即CPU每执行完一条指令，就自动产生一次内部中断。</p>
<h3 id="8086引脚及功能">8086引脚及功能</h3>
<p>8086有40条引脚（PIN）双列直插式（DIP）封装。<br>
引脚太多仅列出部分重点，剩余查询教材P56。<br>
NMI：非屏蔽中断请求，输入，上升沿有效。NMI是上升沿触发的非屏蔽中断请求输入信号，它不能通过软件进行屏蔽，只要引脚上出现一个从低到高的电脉冲，就能使CPU现行指令结束，立即进入中断响应，转去执行NMI中断处理。<br>
INTR：可屏蔽中断请求，输入，高电平有效。INTR是电平触发，CPU在每条指令的最后一个时钟周期对INTR信号线采样，若发现INTR引脚信号为高电平，同时CPU内部中断允许标志IF=1时，CPU就进入中断响应周期，CPU响应中断时，暂停正在执行的主程序，从数据总线读取中断类型码，根据中断类型码从存储器的中断向量表查询相应的中断服务程序的入口地址，转到该地址去执行中断服务程序，在中断结束之后再返回主程序的断点处继续执行程序。<br>
INTA：中断响应信号，输出，三态，低电平有效，在CPU响应外部中断请求后，发给请求中断的设备回答信号。<br>
ALE：地址锁存允许信号，输出，高电平有效。当地址/数据总线分时传送地址信息时，ALE用作把地址信号锁存入8282/8283或74LS373锁存器的锁存控制信号。<br>
DEN：数据允许，输出，三态，低电平有效，在单CPU系统中如果8286/8287作为数据总线的双向驱动器，则用DEN作为驱动器的选通信号。<br>
DT/R：数据发送/接受控制，输出，三态，在单CPU系统中，如果用8286/8287作为数据总线的双向驱动，这是要用DT/R控制数据传送方向。<br>
WR：写信号，输出，三态，低电平有效，WR信号有效时，表示CPU正在执行写存储器或写I/O口操作。<br>
RD：读信号，输出，三态，低电平有效，RD信号有效时，表示CPU在读存储器或I/O口的数据。</p>
<h3 id="cpu系统总线及其操作">CPU系统总线及其操作</h3>
<p>①总线请求和仲裁阶段。需要使用总线的主模块提出请求，由总线仲裁机构确定把下一个传输周期的总线使用全分配给哪一个请求源。<br>
②寻址阶段。去的使用权的主模块通过总线发出本次要访问的从模块的存储器地址或I/O端口地址，启动参与本次传输的从模块。<br>
③数据传输阶段。主模块和从模块进行数据交换。在主模块发出的控制信号作用下，数据由源模块发出，经数据总线传送到目的模块。<br>
④结束阶段。主、从模块的有关信息从系统总线上撤除，让出总线，以便其他模块能使用。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[微机]第一章计算机基础]]></title>
        <id>https://zbigboom.github.io/post/3/</id>
        <link href="https://zbigboom.github.io/post/3/">
        </link>
        <updated>2020-12-01T07:48:09.000Z</updated>
        <content type="html"><![CDATA[<p>计算机在本质上只能识别0，1表示的二进制数码。一个数在机器中的表示形式称为机器数。</p>
<h3 id="机器数有以下特点">机器数有以下特点</h3>
<p>①机器数的正负号都是数值化的。（一般首位为符号位，0表示正数1表示负数）<br>
②机器数所表示的数的范围收机器字长的限制。</p>
<h3 id="机器字长">机器字长</h3>
<p>①位（bit）：是计算机所能表示的最小数据单位，它只有0，1两种状态。<br>
②字节（Byte）：是一个8位二进制数。<br>
③字（Word）：一般指16位二进制数，也就是两个字节。<br>
④字长（Word Length）：指处理器的二进制位数，是衡量计算机性能的一个重要标志，字长越长精度越高性能越强。</p>
<h3 id="进制简写">进制简写</h3>
<p>二进制-B    八进制-O或Q   十进制-D   十六进制-H</p>
<h3 id="数的表示方法">数的表示方法</h3>
<p>①原码：是数值部分为绝对值，加上0，1表示的“+”“-”的机器数。<br>
②反码：正数的反码与原码相同，负数的反码符号位不变为1，其余位取反。<br>
③补码：正数的补码与原码相同，负数的补码先求反码之后在反码末位加1就是负数的补码。<br>
小结：<br>
①有符号数的三种编码最高位都是符号位。<br>
②正数的三种编码相同。<br>
③8位二进制原码反码补码的数值表示范围不同，分别是-127<sub>+127，-127</sub>+127，-128~+127。<br>
补码的运算：<br>
（x+y）补=2^n+（x+y）=（x）补+（y）补<br>
（x-y）补=2^n+（x-y）=（x）补+（-y）补<br>
（-y）补可以通过连同符号位在内一起取反后+1（求补）<br>
注意：两个数相加之后可能会出现负数的情况，这种情况为“溢出”。<br>
小结：<br>
①补码运算时运算数为补码结果也是补码，根据要求可能会有编码转换。<br>
②在进行减法运算时变为加负数的运算，简化硬件设计。<br>
③运算时Ⅰ 符号位与数值位一起参加运算Ⅱ符号位产生的进位可舍弃Ⅲ要保证运算结果不超过补码所能表示的数的最大范围，否则会出现“溢出”错误。<br>
④无符号数和有符号数的加法运算可用同一电路完成</p>
<h3 id="定点数和浮点数">定点数和浮点数</h3>
<p>定点表示法时小数位置在数中固定不变<br>
①定点纯小数：把小数点固定在最高数值位左边。（小数点本身不占位只是约定固定小数点的位置）<br>
②定点纯整数：把小数点固定在最低数值位右边。<br>
浮点数：把一个数通过改变小数点的位置表示成2的p次幂和绝对值小于1的数s相乘的形式。</p>
<center>N=(2^p)*S</center>
N称为浮点数或实数，S是N的尾数
<p><strong>例 1011.1101 B=（0.10111101 B）<em>（2^4）= 0.10111101</em>(2^100) B</strong><br>
先转化位小数*2^p的形式，然后将p转化为二进制的形式，根据格式要求在不同数位填入数值即得到想要的浮点数。</p>
<h3 id="bcd码">BCD码</h3>
<p>BCD码只是将每个十进制数用四位二进制数表示而且每组四位二进制数之间仍然是逢十进一的关系。<br>
正确的BCD码运算必须对二进制数的运算结果进行调整，使之符合十进制数的运算和进位规律，这种调整称为十进制调整，其规则如下：<br>
①若两个BCD数相加的结果大于9（1001）则应加6（0110）修正。<br>
②若两个BCD数相加的结果在本位上并没有大于9（1001）但是产生了进位，相当于十进制数运算大于等于16则也应加6（0110）修正。</p>
<h3 id="了解bcd码在计算机中有两种表示方式">（了解）BCD码在计算机中有两种表示方式</h3>
<p>①使用1字节表示两位十进制数，称压缩BCD码。<br>
②用8位二进制数表示一位十进制数。<br>
前者占内存少，利用率高；后者占内存多，但其运算及调整相对简单。</p>
<h3 id="了解计算机中非数据信息表示">（了解）计算机中非数据信息表示</h3>
<p>西文：采用ASCII码，这是一种8位代码，最高位可用于奇偶校验，仅用7位码代表字符信息，共有128个字符，其中34种功能码，94种符号。<br>
中文：一个汉字用2字节（256*256=65536种状态）编码，同时每字节最高位区分汉字编码和ASCII码，又称汉字交换码。<br>
图 声 像信息：模拟信息经过采样、量化、编码转换成数字信息，采用二进制编码表示。</p>
<h3 id="微型计算机结构">微型计算机结构</h3>
<p>计算机结构大体分为两类：哈佛结构和冯·诺依曼结构<br>
哈佛结构（了解）：程序和数据空间独立的体系结构，不仅采用不同的存储模块，而且通过各自的总线进行访问。优点是可以并行访问程序和数据从而提升了运行效率，缺点是硬件结构复杂，对输入输出设备的连接和处理要求高。<br>
冯·诺依曼结构：程序和数据共享存储空间和总线，缺点是将分时实现程序和数据的访问，影响了数据处理的速度，但是优点明显，结构简单易于实现。<br>
冯·诺依曼结构的基本思想：<br>
①计算机应由运算器、控制器、存储器、输入输出设备五大部分组成。<br>
②存储器不但能存放数据，也能存放程序。计算机具有区分指令和数据的能力，而且数据和指令都以二进制数的形式存放。<br>
③将事先编好的程序放入存储器中，在指令计数器的控制下，自动高速运行。</p>
<h3 id="微型计算机的硬件">微型计算机的硬件</h3>
<p>分为五个部分：①微处理器（CPU）②内存储器（RAM、ROM）③总线（地址总线AB、数据总线DB、控制总线CB）④接口芯片（I/O接口）⑤输入/输出设备（外设，I/O）。<br>
Ⅰ微处理器（CPU）<br>
分为运算部分和控制部分<br>
①ALU算术逻辑单元：运算核心控制信号作用下完成加减乘除运算和与、或、非和异等逻辑运算。<br>
②ACC累加器：通用寄存器中的一个，它往往提供送入ALU的两个运算操作数中的一个和ALU配合密切。<br>
③RS通用寄存器组：用来加快运算和处理速度。访问寄存器比访问存储器快得多。<br>
④FR状态寄存器：记录计算机运行的某些重要状态，比如是否溢出、是否为零、是否为负等。<br>
⑤SP堆栈指针：用来指示栈顶，其初值由程序员设定。（堆栈是一组寄存器或指定存储器中的某一区域，堆栈中信息存入（Push）和弹出（Pop）过程显示货物堆放的过程，特先进后出（FILO））<br>
⑥PC程序计数器：指示当前要执行的指令地址码，程序中各条指令一般是按执行的顺序存放在存储器中，PC指向第一条指令所在地址编号，每取出一条指令后自动指向后续指令。<br>
⑦IR指令寄存器、ID指令译码器、PLA控制逻辑：这是政改革微处理器的指挥控制中心，它依据事先编好的程序依次从存储器中取出各条指令，放在指令寄存器中，通过指令译码，然后通过控制逻辑在确定的时间向确定的部分发出控制信号。<br>
Ⅱ内存储器<br>
内存储器中存放两类信息，一类是待处理的数据和运算结果，另一类是处理数据的程序。<br>
内存储器通常有两类：随机访问存储器RAM和只读存储器ROM，RAM可以随时写入内容亦可进行修改，ROM事先存储规定好的内容，只能将规定的内容读出，不能改写。<br>
Ⅲ总线<br>
①数据总线DB：用来传输数据，通常包括CPU和内存储器或输入输出设备之间交换数据的双向传输线路。<br>
②地址总线AB：用来传送地址。<br>
③控制总线CB：用来传送控制信号、时序信号和状态信息等，其中每根线的方向是一定的、单向的，但是作为整体，控制总线是双向的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[说明]]></title>
        <id>https://zbigboom.github.io/post/2/</id>
        <link href="https://zbigboom.github.io/post/2/">
        </link>
        <updated>2020-11-30T08:45:51.000Z</updated>
        <content type="html"><![CDATA[<p>这个网站是基于我的GitHub和Gridea完成的一个私人博客网站，所有的图片连接都是由Picgo和GitHub完成。但是有个很严重的问题，就是GitHub被墙这个事情，导致加载很慢而且图片不会显示，我查了很多资料解决的办法有：①电脑端可以通过改hosts的方法可以解决，具体操作百度，或者我的GitHub中NNDL库有写具体修改②这个是所有设备端都可以正常浏览的选项就是挂vpn出去看。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[初 · 心]]></title>
        <id>https://zbigboom.github.io/post/1/</id>
        <link href="https://zbigboom.github.io/post/1/">
        </link>
        <updated>2020-11-29T11:16:59.000Z</updated>
        <content type="html"><![CDATA[<p>这里写有我想要搞这样一个网站博客的初心。</p>
<p>①这也是比较重要的一个点吧，就是不知道从什么时候起，自己的学习能力开始急速下降，一个东西学了很久但是几乎没有什么收获，好像是从高中出来就不知道该怎么去学习了，再加上没有什么压力，自己也就变的很怠慢，结果是成绩很差，是时候做些改变不是么？突然有个想法就是做一份学习笔记，就像自己教自己那样的，施教的人是第一遍学习的我，我得要把知识学懂然后整理总结出来写成一份笔记，受教的人也是我是在复习的我，第二遍学习时可以根据第一遍学习的笔记，说不定还会有一些新的理解。这个想法是受到一个老朋友的启发，我觉得这种方式或许对我有用。另外是学习跟不上我觉得可能还有另外的一些原因吧，就是自己的懒惰，以前学习是有一个动力的目的性很强，但是这个目的性现在看来没有那么强烈了，所以做事也就怠慢了。</p>
<p>②另外想要做这样一个网站的原因是我想分享一些东西，我知道这个网站是不会有人去关注的，所以这些东西也就是自己分享给自己，给以后的自己看看现在的自己的生活和想法。这个网站不像是动态、朋友圈、微博这样的社交网站，这里算是我的秘密基地吧，我可以畅所欲言，我可以分享我很感兴趣的事情，也算是保存我记忆的一种方式吧，所以这个网站里不仅会有我的学习日记也会有一些我的日常分享，这些我不想给所有人看，我只想给未来的自己留下些什么。未来不会像以前那样了，突然的少了些东西，这份我最容易丢的东西就保存在这吧，未来的自己看到也不会迷茫了。<br>
<img src="https://raw.githubusercontent.com/zbigboom/Picgo/master/math.jpeg" alt="数学" loading="lazy"><br>
数学都是这样的道理，做人不也是这个道理么，累了没动力了停下来回头看看自己，然后继续冲下去不是么。</p>
]]></content>
    </entry>
</feed>