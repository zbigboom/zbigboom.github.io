<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zbigboom.github.io</id>
    <title>ZBigBoom</title>
    <updated>2021-04-24T17:54:54.640Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zbigboom.github.io"/>
    <link rel="self" href="https://zbigboom.github.io/atom.xml"/>
    <subtitle>我的世界</subtitle>
    <logo>https://zbigboom.github.io/images/avatar.png</logo>
    <icon>https://zbigboom.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, ZBigBoom</rights>
    <entry>
        <title type="html"><![CDATA[[夜话]人间观察员]]></title>
        <id>https://zbigboom.github.io/post/15/</id>
        <link href="https://zbigboom.github.io/post/15/">
        </link>
        <updated>2021-04-24T16:14:02.000Z</updated>
        <content type="html"><![CDATA[<p>最近看到一个词叫做人间观察员,我的理解是这是我们每个人都在扮演的一个角色只是可能我们没有意识到我们在扮演这样的一个角色,其实停下来走慢点看看身边发生的,很多其实是很有意思的.最近可能因为我看的东西的影响我观察的角度好像偏向了一个话题,叫做&quot;什么是爱&quot;挺奇怪的但是也挺有意思的.<br>
什么是爱,这个问题有正确答案么?似乎没有,没有一个定理,一个公式,一段具体的描述能将它表述出来,爱存在么似乎都成了一个问题.但是我相信它是存在的,不是以物质或能量的形式,但是存在的,就如同笛卡尔说的&quot;我思故我在&quot;一样,它看不见摸不着但确确实实存在,至少在我的认知中存在.最近看了&lt;&lt;霍乱时期的爱情&gt;&gt;<br>
讲的是爱情,算是爱的一种形式吧,我认为的书中描述了两种爱情的形式吧,一种是弗尔米纳和乌尔比诺医生之间的,另外一种是弗尔米纳和弗洛伦蒂纳之间的,前者看起来很美好但是弗尔米纳却说&quot;浮华而已&quot;的爱,后者是看起来很悲惨但是&quot;一生一世&quot;,判别不出哪一种是真的爱情,但是可以说爱这个&quot;东西&quot;是存在的,甚至弗洛伦蒂纳用一生去爱着弗尔米纳,爱贯穿了时间.虽然这是一本小说,但描绘的故事是被爱情包裹着的,说明确实有爱的存在,甚至有人想将它描述出来.现在可以说爱是存在的,但爱是什么?<br>
有些东西得要换个角度看看,最近又看了一遍&lt;&lt;星际穿越&gt;&gt;一部很棒的电影,第一次看的时候让我大开眼界,对世界都有了新的认识,影片里有一些概念,我第一遍看的时候认识到的&quot;四维&quot;&quot;五维&quot;,用维度来描述空间,我们生活的三维的空间,零维是一个点,一维是一条线,二维是一个平面,三维是一个空间,四维是时间,这是一般的认知,第一遍看的时候我认位第五维的存在是引力,以上这些维度可以从两个方向看,低维向高维看去可以看成扩展,点扩展成线这样,但是从高维看,可以是贯穿,线贯穿了点,这样就理解了第五维引力贯穿了前面的低维,不同的引力可以产生不同的低维空间.这是我第一遍看的时候理解到的,但是现在我第二次去看它,又有了新的认知,在这五维之上还有一个很重要的是爱,在我认为或许爱是一种更高的维度,它贯穿了前面的低维,因为在影片中库珀给墨菲传递信息的动机是爱,是一个父亲的爱,他本身就在一个高维的空间,而爱是恒定不变的,爱没有因为高维的改变而改变,也就是爱贯穿了这个高维空间,如果爱能具象化表示出来,它是贯穿低维的一条线.所以爱像是一条纽带一样,看不见摸不着,但是它存在而且能量很强.<br>
其实以上这些都算是哲学解释什么是爱,但生活中其实也能观察的到,就比如一个人注意力,一个人坐着目视着前方没有任何干扰,他就坐在那里看着前方,但是如果这时候在他右边发生了爆炸,那么他的身体会有反应,身体会向右偏而且目光不再是前方而是右方,也就是他的注意力被右方吸引,这是一种影响,它也是看不见的,但是它存在且有能量,那将这个爆炸换成是这个人爱的东西,比如他爱的人,他爱的东西,他也会向右偏.这可比那种高维能量容易理解得多.<br>
所以爱是什么?没有标准答案,在我的认知里爱是存在的,是一种纽带而且能量很强,不论是人之间的还是其他的,它都具有很强的能量会影响人,是一种强相互作用,虽然看不见摸不着说不明白,但要相信它.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Web]爬虫&知乎]]></title>
        <id>https://zbigboom.github.io/post/14/</id>
        <link href="https://zbigboom.github.io/post/14/">
        </link>
        <updated>2021-04-23T18:11:37.000Z</updated>
        <summary type="html"><![CDATA[<p>学习了nndl但是遇到一个问题，没有合适的数据集，在做RNN的时候使用的数据集大多是经典的数据集，网络上可以搜索的到，通过一些实例就可以调用使用，甚至tensorflow中有经典数据集下载的工具，但是对于某些特殊的数据集需要自己整理，如果采用人工收集整理的方式效率很低而且工作量会很大。所以想要通过爬虫爬取数据的方式来收集数据，制作数据集。现在想要做的方向是NLP，可以通过收集某些问答网站的评论回答来制作数据集，需要学习的东西有，①爬虫，在学习python时没有系统学习过如何使用爬虫，和爬虫的基本原理及用法，这部分是需要学习的②正则化，爬虫爬取的数据需要正则化表示才能够进行分析③数据库，将爬虫爬取的数据按一定格式和索引进行保存，方便学习是导入调用。</p>
]]></summary>
        <content type="html"><![CDATA[<p>学习了nndl但是遇到一个问题，没有合适的数据集，在做RNN的时候使用的数据集大多是经典的数据集，网络上可以搜索的到，通过一些实例就可以调用使用，甚至tensorflow中有经典数据集下载的工具，但是对于某些特殊的数据集需要自己整理，如果采用人工收集整理的方式效率很低而且工作量会很大。所以想要通过爬虫爬取数据的方式来收集数据，制作数据集。现在想要做的方向是NLP，可以通过收集某些问答网站的评论回答来制作数据集，需要学习的东西有，①爬虫，在学习python时没有系统学习过如何使用爬虫，和爬虫的基本原理及用法，这部分是需要学习的②正则化，爬虫爬取的数据需要正则化表示才能够进行分析③数据库，将爬虫爬取的数据按一定格式和索引进行保存，方便学习是导入调用。</p>
<!-- more -->
<p>目前已经完成的是爬虫部分，爬虫使用requests库和lxml库<br>
以知乎为例，需要先编写headers和url这些在知乎首页登录后按F12可以查看</p>
<pre><code>headers={
    'user-agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36',
    'cookie': '_zap=33a43153-9eb5-4589-ad90-a692d6005551; d_c0=&quot;APDbLCtEIhKPTvTGXezwgGYuHiUrCZuacDU=|1604317216&quot;; _xsrf=6c1c6d60-efaf-4fc3-a237-9ef187b6635a; captcha_session_v2=&quot;2|1:0|10:1618591064|18:captcha_session_v2|88:SHA4bGFXeTE3MW5JUzlsZ0FZNWdEQ1pjZldVYlppRjk0SUhFQzZJRXZ1YzE5SGY1TEhqai9YK3QzeEVIck91Ng==|8522a5a0ef1e5c859248be24ec5a4a8f33f5aa753a56870d8f3046019f095e03&quot;; SESSIONID=fEYhlYimk5rIJ1nvRQTNrS8qdGo1KM8BvucORQzBAfG; JOID=W1sTB0_HeUGdjYrJZspenYmiw-x7qzka9ezZpQmhRjbWx7atFZHDOvCKhc5kmDBG3aoKRtKccU7AY_eLE9eDQes=; osd=U1gTBEvPekGeiYLKZslalYqiwOhzqDkZ8eTapQqlTjXWxLKlFpHAPviJhc1gkDNG3q4CRdKfdUbDY_SPG9SDQu8=; __snaker__id=hPVJ7ljiiG1lEbon; gdxidpyhxdE=e5kQI057%5C3EHzgwk1IoP%2FJkS6m0JVVVUmdVWx4lkJbwV3U3XdrlvsZNw5YiKAiQgtAinpEl4zUSdOJrz%2FSeNkO6S2PrN8szQe1%5ChyB8BlVGaEq3hPX2Q0MN9JGtCTlV0ktH%5C%2FNtS9zSsXhRGRsp6k0rn%2BDMc%5CjjzLMUzkmgzeI6KWOp3%3A1618591982486; _9755xjdesxxd_=32; YD00517437729195%3AWM_NI=3bRp01XZR0uEhNrGTvss7rqJEe%2BtftaOEbJA4f1oeAezE%2BeM7UnekclCFThH5h%2B24oTVyfnb9pkyqaNWM6V0w%2FJo%2BB9u8wIfODaZnklwUWqKm%2BtxV496QKajhWjWq7mKbDk%3D; YD00517437729195%3AWM_NIKE=9ca17ae2e6ffcda170e2e6ee92bc25ed98fb82d97fed968ab7c55f868f9abbb661a6bf8599dc219b94f797c12af0fea7c3b92af1be9e91b33b9c869ed1f84fac92bea8d77eb1adf993f44287bbe595e580a3918b83c94bf8baff90e84ba7a68bcce847f58ba286ea69b09d8ab5eb44f7b8e5d3b765988ab787ed6afbb0a59af46b8e8983d7d53cb5f18690aa4afbabf898cc6e8d9cafbbed61b0a99bb8f441aff5bc99d540fbea9face462ac89a6b8f43daf95aea5ea37e2a3; YD00517437729195%3AWM_TID=zf%2FTyLJxHMdEBVRVVQdrxfeOgY%2FMP4uE; Hm_lvt_98beee57fd2ef70ccdd5ca52b9740c49=1618225129,1618233102,1618591082,1618591091; z_c0=&quot;2|1:0|10:1618591107|4:z_c0|92:Mi4xMHIxdkNBQUFBQUFBOE5zc0swUWlFaWNBQUFDRUFsVk5na3FoWUFEU3dNWTFRY2staEwwMWNPOUFTX2d0STY0aDR3|f9a1c3a722b771962977d0cb535ac933961ddf51231b4795abdc9f9c8f5eef31&quot;; tst=r; Hm_lpvt_98beee57fd2ef70ccdd5ca52b9740c49=1618591136; KLBRSID=0a401b23e8a71b70de2f4b37f5b4e379|1618591507|1618591064'
}
url='https://www.zhihu.com/hot'
</code></pre>
<p>第二步是get网站,获取网站内容</p>
<pre><code>    response=requests.get(url,headers=headers)
</code></pre>
<p>第三步是将网站内容做成列表,获取需要提取的内容</p>
<pre><code>    text=response.text
    html=etree.HTML(text)
    reslut=html.xpath(&quot;//section[@class='HotItem']&quot;)
    # 问题id
    question_list=[]
    for question in reslut:
        number=question.xpath(&quot;.//div[@class='HotItem-index']//text()&quot;)[0].strip()
        title=question.xpath(&quot;.//h2[@class='HotItem-title']/text()&quot;)[0].strip()
        href=question.xpath(&quot;.//div[@class='HotItem-content']/a/@href&quot;)[0].strip()
        question_num=href.strip('/')[-1]
        question_list.append([question_num,title])
</code></pre>
<p>可以获得知乎热榜的问题和问题id及问题内容,完整的代码:</p>
<pre><code>headers={
    'user-agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36',
    'cookie': '_zap=33a43153-9eb5-4589-ad90-a692d6005551; d_c0=&quot;APDbLCtEIhKPTvTGXezwgGYuHiUrCZuacDU=|1604317216&quot;; _xsrf=6c1c6d60-efaf-4fc3-a237-9ef187b6635a; captcha_session_v2=&quot;2|1:0|10:1618591064|18:captcha_session_v2|88:SHA4bGFXeTE3MW5JUzlsZ0FZNWdEQ1pjZldVYlppRjk0SUhFQzZJRXZ1YzE5SGY1TEhqai9YK3QzeEVIck91Ng==|8522a5a0ef1e5c859248be24ec5a4a8f33f5aa753a56870d8f3046019f095e03&quot;; SESSIONID=fEYhlYimk5rIJ1nvRQTNrS8qdGo1KM8BvucORQzBAfG; JOID=W1sTB0_HeUGdjYrJZspenYmiw-x7qzka9ezZpQmhRjbWx7atFZHDOvCKhc5kmDBG3aoKRtKccU7AY_eLE9eDQes=; osd=U1gTBEvPekGeiYLKZslalYqiwOhzqDkZ8eTapQqlTjXWxLKlFpHAPviJhc1gkDNG3q4CRdKfdUbDY_SPG9SDQu8=; __snaker__id=hPVJ7ljiiG1lEbon; gdxidpyhxdE=e5kQI057%5C3EHzgwk1IoP%2FJkS6m0JVVVUmdVWx4lkJbwV3U3XdrlvsZNw5YiKAiQgtAinpEl4zUSdOJrz%2FSeNkO6S2PrN8szQe1%5ChyB8BlVGaEq3hPX2Q0MN9JGtCTlV0ktH%5C%2FNtS9zSsXhRGRsp6k0rn%2BDMc%5CjjzLMUzkmgzeI6KWOp3%3A1618591982486; _9755xjdesxxd_=32; YD00517437729195%3AWM_NI=3bRp01XZR0uEhNrGTvss7rqJEe%2BtftaOEbJA4f1oeAezE%2BeM7UnekclCFThH5h%2B24oTVyfnb9pkyqaNWM6V0w%2FJo%2BB9u8wIfODaZnklwUWqKm%2BtxV496QKajhWjWq7mKbDk%3D; YD00517437729195%3AWM_NIKE=9ca17ae2e6ffcda170e2e6ee92bc25ed98fb82d97fed968ab7c55f868f9abbb661a6bf8599dc219b94f797c12af0fea7c3b92af1be9e91b33b9c869ed1f84fac92bea8d77eb1adf993f44287bbe595e580a3918b83c94bf8baff90e84ba7a68bcce847f58ba286ea69b09d8ab5eb44f7b8e5d3b765988ab787ed6afbb0a59af46b8e8983d7d53cb5f18690aa4afbabf898cc6e8d9cafbbed61b0a99bb8f441aff5bc99d540fbea9face462ac89a6b8f43daf95aea5ea37e2a3; YD00517437729195%3AWM_TID=zf%2FTyLJxHMdEBVRVVQdrxfeOgY%2FMP4uE; Hm_lvt_98beee57fd2ef70ccdd5ca52b9740c49=1618225129,1618233102,1618591082,1618591091; z_c0=&quot;2|1:0|10:1618591107|4:z_c0|92:Mi4xMHIxdkNBQUFBQUFBOE5zc0swUWlFaWNBQUFDRUFsVk5na3FoWUFEU3dNWTFRY2staEwwMWNPOUFTX2d0STY0aDR3|f9a1c3a722b771962977d0cb535ac933961ddf51231b4795abdc9f9c8f5eef31&quot;; tst=r; Hm_lpvt_98beee57fd2ef70ccdd5ca52b9740c49=1618591136; KLBRSID=0a401b23e8a71b70de2f4b37f5b4e379|1618591507|1618591064'
}
url='https://www.zhihu.com/hot'

def get_question_num(url,headers):
    response=requests.get(url,headers=headers)
    text=response.text
    html=etree.HTML(text)
    reslut=html.xpath(&quot;//section[@class='HotItem']&quot;)
    # 问题id
    question_list=[]
    for question in reslut:
        number=question.xpath(&quot;.//div[@class='HotItem-index']//text()&quot;)[0].strip()
        title=question.xpath(&quot;.//h2[@class='HotItem-title']/text()&quot;)[0].strip()
        href=question.xpath(&quot;.//div[@class='HotItem-content']/a/@href&quot;)[0].strip()
        question_num=href.strip('/')[-1]
        question_list.append([question_num,title])
    return question_list
</code></pre>
<p>现在有了问题id想要获取这个问题的回答,但是遇到了很大的麻烦,因为是第一次编爬虫本来就是新手,还遇到了一个有反爬虫的网站令人头疼,在get问题url时获得404警告,禁止访问,然后查了很多大佬的教程和文章,花了很长时间明白了,知乎的反爬虫破解需要在headers中加入一个x-zse-86+加密文的内容,需要做的是了解知乎的密文是如何加密的,还是在浏览器端查响应和网站代码,Ctrl+f查询x-zse-86的信息,可以查到这段密文有两次加密,第一次是通过问题的url用MD5的方式加密,之后用加密后的32位密文通过知乎自己的加密方式生成新的密文,第一种方式比较容易解决通过MD5加密就行,第二步不能用猜或者很简单的方式进行,所以可以通过之间查网站的代码,扒取相关函数,生成一个js文件(这部分超纲了,完全看不懂)学习到大佬的做法是打断点慢慢调试扒出相关函数,然后写成一个js文件,在进行爬虫的时候可以调用这个js获得加密后的密文<br>
新的headers应该是</p>
<pre><code>headers = {

    &quot;user-agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36&quot;,
    &quot;cookie&quot;: 'd_c0=&quot;APDbLCtEIhKPTvTGXezwgGYuHiUrCZuacDU=|1604317216&quot;;',
    &quot;x-api-version&quot;: &quot;3.0.91&quot;,
    &quot;x-zse-83&quot;: &quot;3_2.0&quot;,
    &quot;x-zse-86&quot;: &quot;1.0_%s&quot; % encrypt_str,
}
</code></pre>
<p>加密的js代码为</p>
<pre><code>const jsdom = require(&quot;jsdom&quot;);
const { JSDOM } = jsdom;
const dom = new JSDOM(`&lt;!DOCTYPE html&gt;&lt;p&gt;Hello world&lt;/p&gt;`);
window = dom.window;
document = window.document;
XMLHttpRequest = window.XMLHttpRequest;

	var exports = {}
	function t(e) {
        return (t = &quot;function&quot; == typeof Symbol &amp;&amp; &quot;symbol&quot; == typeof Symbol.A ? function(e) {
            return typeof e
        }
        : function(e) {
            return e &amp;&amp; &quot;function&quot; == typeof Symbol &amp;&amp; e.constructor === Symbol &amp;&amp; e !== Symbol.prototype ? &quot;symbol&quot; : typeof e
        }
        )(e)
    }
    Object.defineProperty(exports, &quot;__esModule&quot;, {
        value: !0
    });
    var A = &quot;2.0&quot;
      , __g = {};
    function s() {}
    function i(e) {
        this.t = (2048 &amp; e) &gt;&gt; 11,
        this.s = (1536 &amp; e) &gt;&gt; 9,
        this.i = 511 &amp; e,
        this.h = 511 &amp; e
    }
    function h(e) {
        this.s = (3072 &amp; e) &gt;&gt; 10,
        this.h = 1023 &amp; e
    }
    function a(e) {
        this.a = (3072 &amp; e) &gt;&gt; 10,
        this.c = (768 &amp; e) &gt;&gt; 8,
        this.n = (192 &amp; e) &gt;&gt; 6,
        this.t = 63 &amp; e
    }
    function c(e) {
        this.s = e &gt;&gt; 10 &amp; 3,
        this.i = 1023 &amp; e
    }
    function n() {}
    function e(e) {
        this.a = (3072 &amp; e) &gt;&gt; 10,
        this.c = (768 &amp; e) &gt;&gt; 8,
        this.n = (192 &amp; e) &gt;&gt; 6,
        this.t = 63 &amp; e
    }
    function o(e) {
        this.h = (4095 &amp; e) &gt;&gt; 2,
        this.t = 3 &amp; e
    }
    function r(e) {
        this.s = e &gt;&gt; 10 &amp; 3,
        this.i = e &gt;&gt; 2 &amp; 255,
        this.t = 3 &amp; e
    }
    s.prototype.e = function(e) {
        e.o = !1
    }
    ,
    i.prototype.e = function(e) {
        switch (this.t) {
        case 0:
            e.r[this.s] = this.i;
            break;
        case 1:
            e.r[this.s] = e.k[this.h]
        }
    }
    ,
    h.prototype.e = function(e) {
        e.k[this.h] = e.r[this.s]
    }
    ,
    a.prototype.e = function(e) {
        switch (this.t) {
        case 0:
            e.r[this.a] = e.r[this.c] + e.r[this.n];
            break;
        case 1:
            e.r[this.a] = e.r[this.c] - e.r[this.n];
            break;
        case 2:
            e.r[this.a] = e.r[this.c] * e.r[this.n];
            break;
        case 3:
            e.r[this.a] = e.r[this.c] / e.r[this.n];
            break;
        case 4:
            e.r[this.a] = e.r[this.c] % e.r[this.n];
            break;
        case 5:
            e.r[this.a] = e.r[this.c] == e.r[this.n];
            break;
        case 6:
            e.r[this.a] = e.r[this.c] &gt;= e.r[this.n];
            break;
        case 7:
            e.r[this.a] = e.r[this.c] || e.r[this.n];
            break;
        case 8:
            e.r[this.a] = e.r[this.c] &amp;&amp; e.r[this.n];
            break;
        case 9:
            e.r[this.a] = e.r[this.c] !== e.r[this.n];
            break;
        case 10:
            e.r[this.a] = t(e.r[this.c]);
            break;
        case 11:
            e.r[this.a] = e.r[this.c]in e.r[this.n];
            break;
        case 12:
            e.r[this.a] = e.r[this.c] &gt; e.r[this.n];
            break;
        case 13:
            e.r[this.a] = -e.r[this.c];
            break;
        case 14:
            e.r[this.a] = e.r[this.c] &lt; e.r[this.n];
            break;
        case 15:
            e.r[this.a] = e.r[this.c] &amp; e.r[this.n];
            break;
        case 16:
            e.r[this.a] = e.r[this.c] ^ e.r[this.n];
            break;
        case 17:
            e.r[this.a] = e.r[this.c] &lt;&lt; e.r[this.n];
            break;
        case 18:
            e.r[this.a] = e.r[this.c] &gt;&gt;&gt; e.r[this.n];
            break;
        case 19:
            e.r[this.a] = e.r[this.c] | e.r[this.n];
            break;
        case 20:
            e.r[this.a] = !e.r[this.c]
        }
    }
    ,
    c.prototype.e = function(e) {
        e.Q.push(e.C),
        e.B.push(e.k),
        e.C = e.r[this.s],
        e.k = [];
        for (var t = 0; t &lt; this.i; t++)
            e.k.unshift(e.f.pop());
        e.g.push(e.f),
        e.f = []
    }
    ,
    n.prototype.e = function(e) {
        e.C = e.Q.pop(),
        e.k = e.B.pop(),
        e.f = e.g.pop()
    }
    ,
    e.prototype.e = function(e) {
        switch (this.t) {
        case 0:
            e.u = e.r[this.a] &gt;= e.r[this.c];
            break;
        case 1:
            e.u = e.r[this.a] &lt;= e.r[this.c];
            break;
        case 2:
            e.u = e.r[this.a] &gt; e.r[this.c];
            break;
        case 3:
            e.u = e.r[this.a] &lt; e.r[this.c];
            break;
        case 4:
            e.u = e.r[this.a] == e.r[this.c];
            break;
        case 5:
            e.u = e.r[this.a] != e.r[this.c];
            break;
        case 6:
            e.u = e.r[this.a];
            break;
        case 7:
            e.u = !e.r[this.a]
        }
    }
    ,
    o.prototype.e = function(e) {
        switch (this.t) {
        case 0:
            e.C = this.h;
            break;
        case 1:
            e.u &amp;&amp; (e.C = this.h);
            break;
        case 2:
            e.u || (e.C = this.h);
            break;
        case 3:
            e.C = this.h,
            e.w = null
        }
        e.u = !1
    }
    ,
    r.prototype.e = function(e) {
        switch (this.t) {
        case 0:
            for (var t = [], n = 0; n &lt; this.i; n++)
                t.unshift(e.f.pop());
            e.r[3] = e.r[this.s](t[0], t[1]);
            break;
        case 1:
            for (var r = e.f.pop(), o = [], i = 0; i &lt; this.i; i++)
                o.unshift(e.f.pop());
            e.r[3] = e.r[this.s][r](o[0], o[1]);
            break;
        case 2:
            for (var a = [], c = 0; c &lt; this.i; c++)
                a.unshift(e.f.pop());
            e.r[3] = new e.r[this.s](a[0],a[1])
        }
    }
    ;
    var k = function(e) {
        for (var t = 66, n = [], r = 0; r &lt; e.length; r++) {
            var o = 24 ^ e.charCodeAt(r) ^ t;
            n.push(String.fromCharCode(o)),
            t = o
        }
        return n.join(&quot;&quot;)
    };
    function Q(e) {
        this.t = (4095 &amp; e) &gt;&gt; 10,
        this.s = (1023 &amp; e) &gt;&gt; 8,
        this.i = 1023 &amp; e,
        this.h = 63 &amp; e
    }
    function C(e) {
        this.t = (4095 &amp; e) &gt;&gt; 10,
        this.a = (1023 &amp; e) &gt;&gt; 8,
        this.c = (255 &amp; e) &gt;&gt; 6
    }
    function B(e) {
        this.s = (3072 &amp; e) &gt;&gt; 10,
        this.h = 1023 &amp; e
    }
    function f(e) {
        this.h = 4095 &amp; e
    }
    function g(e) {
        this.s = (3072 &amp; e) &gt;&gt; 10
    }
    function u(e) {
        this.h = 4095 &amp; e
    }
    function w(e) {
        this.t = (3840 &amp; e) &gt;&gt; 8,
        this.s = (192 &amp; e) &gt;&gt; 6,
        this.i = 63 &amp; e
    }
    function G() {
        this.r = [0, 0, 0, 0],
        this.C = 0,
        this.Q = [],
        this.k = [],
        this.B = [],
        this.f = [],
        this.g = [],
        this.u = !1,
        this.G = [],
        this.b = [],
        this.o = !1,
        this.w = null,
        this.U = null,
        this.F = [],
        this.R = 0,
        this.J = {
            0: s,
            1: i,
            2: h,
            3: a,
            4: c,
            5: n,
            6: e,
            7: o,
            8: r,
            9: Q,
            10: C,
            11: B,
            12: f,
            13: g,
            14: u,
            15: w
        }
    }
    Q.prototype.e = function(e) {
        switch (this.t) {
        case 0:
            e.f.push(e.r[this.s]);
            break;
        case 1:
            e.f.push(this.i);
            break;
        case 2:
            e.f.push(e.k[this.h]);
            break;
        case 3:
            e.f.push(k(e.b[this.h]))
        }
    }
    ,
    C.prototype.e = function(A) {
        switch (this.t) {
        case 0:
            var t = A.f.pop();
            A.r[this.a] = A.r[this.c][t];
            break;
        case 1:
            var s = A.f.pop()
              , i = A.f.pop();
            A.r[this.c][s] = i;
            break;
        case 2:
            var h = A.f.pop();
            A.r[this.a] = eval(h)
        }
    }
    ,
    B.prototype.e = function(e) {
        e.r[this.s] = k(e.b[this.h])
    }
    ,
    f.prototype.e = function(e) {
        e.w = this.h
    }
    ,
    g.prototype.e = function(e) {
        throw e.r[this.s]
    }
    ,
    u.prototype.e = function(e) {
        var t = this
          , n = [0];
        e.k.forEach(function(e) {
            n.push(e)
        });
        var r = function(r) {
            var o = new G;
            return o.k = n,
            o.k[0] = r,
            o.v(e.G, t.h, e.b, e.F),
            o.r[3]
        };
        r.toString = function() {
            return &quot;() { [native code] }&quot;
        }
        ,
        e.r[3] = r
    }
    ,
    w.prototype.e = function(e) {
        switch (this.t) {
        case 0:
            for (var t = {}, n = 0; n &lt; this.i; n++) {
                var r = e.f.pop();
                t[e.f.pop()] = r
            }
            e.r[this.s] = t;
            break;
        case 1:
            for (var o = [], i = 0; i &lt; this.i; i++)
                o.unshift(e.f.pop());
            e.r[this.s] = o
        }
    }
    ,
    G.prototype.D = function(e) {
        console.log(window.atob(e));
        for (var t = window.atob(e), n = t.charCodeAt(0) &lt;&lt; 8 | t.charCodeAt(1), r = [], o = 2; o &lt; n + 2; o += 2)
            r.push(t.charCodeAt(o) &lt;&lt; 8 | t.charCodeAt(o + 1));
        this.G = r;
        for (var i = [], a = n + 2; a &lt; t.length; ) {
            var c = t.charCodeAt(a) &lt;&lt; 8 | t.charCodeAt(a + 1)
              , s = t.slice(a + 2, a + 2 + c);
            i.push(s),
            a += c + 2
        }
        this.b = i
    }
    ,
    G.prototype.v = function(e, t, n) {
        for (t = t || 0,
        n = n || [],
        this.C = t,
        &quot;string&quot; == typeof e ? this.D(e) : (this.G = e,
        this.b = n),
        this.o = !0,
        this.R = Date.now(); this.o; ) {
            var r = this.G[this.C++];
            if (&quot;number&quot; != typeof r)
                break;
            var o = Date.now();
            if (500 &lt; o - this.R)
                return;
            this.R = o;
            try {
                this.e(r)
            } catch (e) {
                this.U = e,
                this.w &amp;&amp; (this.C = this.w)
            }
        }
    }
    ,
    G.prototype.e = function(e) {
        var t = (61440 &amp; e) &gt;&gt; 12;
        new this.J[t](e).e(this)
    }
    ,
     (new G).v(&quot;AxjgB5MAnACoAJwBpAAAABAAIAKcAqgAMAq0AzRJZAZwUpwCqACQACACGAKcBKAAIAOcBagAIAQYAjAUGgKcBqFAuAc5hTSHZAZwqrAIGgA0QJEAJAAYAzAUGgOcCaFANRQ0R2QGcOKwChoANECRACQAsAuQABgDnAmgAJwMgAGcDYwFEAAzBmAGcSqwDhoANECRACQAGAKcD6AAGgKcEKFANEcYApwRoAAxB2AGcXKwEhoANECRACQAGAKcE6AAGgKcFKFANEdkBnGqsBUaADRAkQAkABgCnBagAGAGcdKwFxoANECRACQAGAKcGKAAYAZx+rAZGgA0QJEAJAAYA5waoABgBnIisBsaADRAkQAkABgCnBygABoCnB2hQDRHZAZyWrAeGgA0QJEAJAAYBJwfoAAwFGAGcoawIBoANECRACQAGAOQALAJkAAYBJwfgAlsBnK+sCEaADRAkQAkABgDkACwGpAAGAScH4AJbAZy9rAiGgA0QJEAJACwI5AAGAScH6AAkACcJKgAnCWgAJwmoACcJ4AFnA2MBRAAMw5gBnNasCgaADRAkQAkABgBEio0R5EAJAGwKSAFGACcKqAAEgM0RCQGGAYSATRFZAZzshgAtCs0QCQAGAYSAjRFZAZz1hgAtCw0QCQAEAAgB7AtIAgYAJwqoAASATRBJAkYCRIANEZkBnYqEAgaBxQBOYAoBxQEOYQ0giQKGAmQABgAnC6ABRgBGgo0UhD/MQ8zECALEAgaBxQBOYAoBxQEOYQ0gpEAJAoYARoKNFIQ/zEPkAAgChgLGgkUATmBkgAaAJwuhAUaCjdQFAg5kTSTJAsQCBoHFAE5gCgHFAQ5hDSCkQAkChgBGgo0UhD/MQ+QACAKGAsaCRQCOYGSABoAnC6EBRoKN1AUEDmRNJMkCxgFGgsUPzmPkgAaCJwvhAU0wCQFGAUaCxQGOZISPzZPkQAaCJwvhAU0wCQFGAUaCxQMOZISPzZPkQAaCJwvhAU0wCQFGAUaCxQSOZISPzZPkQAaCJwvhAU0wCQFGAkSAzRBJAlz/B4FUAAAAwUYIAAIBSITFQkTERwABi0GHxITAAAJLwMSGRsXHxMZAAk0Fw8HFh4NAwUABhU1EBceDwAENBcUEAAGNBkTGRcBAAFKAAkvHg4PKz4aEwIAAUsACDIVHB0QEQ4YAAsuAzs7AAoPKToKDgAHMx8SGQUvMQABSAALORoVGCQgERcCAxoACAU3ABEXAgMaAAsFGDcAERcCAxoUCgABSQAGOA8LGBsPAAYYLwsYGw8AAU4ABD8QHAUAAU8ABSkbCQ4BAAFMAAktCh8eDgMHCw8AAU0ADT4TGjQsGQMaFA0FHhkAFz4TGjQsGQMaFA0FHhk1NBkCHgUbGBEPAAFCABg9GgkjIAEmOgUHDQ8eFSU5DggJAwEcAwUAAUMAAUAAAUEADQEtFw0FBwtdWxQTGSAACBwrAxUPBR4ZAAkqGgUDAwMVEQ0ACC4DJD8eAx8RAAQ5GhUYAAFGAAAABjYRExELBAACWhgAAVoAQAg/PTw0NxcQPCQ5C3JZEBs9fkcnDRcUAXZia0Q4EhQgXHojMBY3MWVCNT0uDhMXcGQ7AUFPHigkQUwQFkhaAkEACjkTEQspNBMZPC0ABjkTEQsrLQ==&quot;);
     function b(e) {
         console.log(e);
         console.log(encodeURIComponent(e));
        return __g._encrypt(encodeURIComponent(e))
    };
</code></pre>
<p>调用js需要nodejs支持,可以通过官网下载配置全局环境,在全局使用npm install jsdom安装库之后就可以在python中调用js文件<br>
现在有了问题的url有了headers有了加密方式就可以爬取知乎问题的内容了,爬取后正则化表示和数据库保存就是下一个阶段需要学习努力的方向<br>
完整代码</p>
<pre><code>import requests
import execjs
import hashlib


url = &quot;/api/v4/questions/454944228/answers?include=data%5B%2A%5D.is_normal%2Cadmin_closed_comment%2Creward_info%2Cis_collapsed%2Cannotation_action%2Cannotation_detail%2Ccollapse_reason%2Cis_sticky%2Ccollapsed_by%2Csuggest_edit%2Ccomment_count%2Ccan_comment%2Ccontent%2Ceditable_content%2Cattachment%2Cvoteup_count%2Creshipment_settings%2Ccomment_permission%2Ccreated_time%2Cupdated_time%2Creview_info%2Crelevant_info%2Cquestion%2Cexcerpt%2Cis_labeled%2Cpaid_info%2Cpaid_info_content%2Crelationship.is_authorized%2Cis_author%2Cvoting%2Cis_thanked%2Cis_nothelp%2Cis_recognized%3Bdata%5B%2A%5D.mark_infos%5B%2A%5D.url%3Bdata%5B%2A%5D.author.follower_count%2Cbadge%5B%2A%5D.topics%3Bdata%5B%2A%5D.settings.table_of_content.enabled&amp;limit=5&amp;offset=5&amp;platform=desktop&amp;sort_by=default&quot;

f = &quot;+&quot;.join([&quot;3_2.0&quot;, url,'&quot;APDbLCtEIhKPTvTGXezwgGYuHiUrCZuacDU=|1604317216&quot;'])

fmd5 = hashlib.new('md5', f.encode()).hexdigest()

with open('g_encrypt.js', 'r') as f:
    ctx1 = execjs.compile(f.read(), cwd=r'C:\Users\MRCHENIKE\node_modules')
encrypt_str = ctx1.call('b', fmd5)

headers = {

    &quot;user-agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36&quot;,
    &quot;cookie&quot;: 'd_c0=&quot;APDbLCtEIhKPTvTGXezwgGYuHiUrCZuacDU=|1604317216&quot;;',
    &quot;x-api-version&quot;: &quot;3.0.91&quot;,
    &quot;x-zse-83&quot;: &quot;3_2.0&quot;,
    &quot;x-zse-86&quot;: &quot;1.0_%s&quot; % encrypt_str,
}
print(headers)
r = requests.get(&quot;https://www.zhihu.com&quot; + url, headers=headers)

all_detail_data = r.json()['data']
length_detail_data = len(all_detail_data)
txt_1=open(&quot;txt1.txt&quot;,&quot;w&quot;)
for one_detail_data in all_detail_data:

    answer_author = one_detail_data['author']['name']
    author_introduce = one_detail_data['author']['headline']
    author_followers = one_detail_data['author']['follower_count']
    answer_vote_num = one_detail_data['voteup_count']
    answer_comment_num = one_detail_data['comment_count']
    updated_time = one_detail_data['updated_time']
    content = one_detail_data['content']
    txt_1.write(content)
txt_1.close()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[夜话]日常？]]></title>
        <id>https://zbigboom.github.io/post/13/</id>
        <link href="https://zbigboom.github.io/post/13/">
        </link>
        <updated>2021-03-24T18:30:37.000Z</updated>
        <summary type="html"><![CDATA[<p>我觉的夜话快成了考研周记，不知道过了今年看到这些夜话心里会是什么感受，最近天气慢慢变好果然阳光明媚是会给人带来好心情还有好运气的。希望天气能再热一点我是真的没有在这个温度下穿的衣服，家里那边只有两种季节叫做冬季和大约在冬季，所以衣服只有很厚或者很薄的，但是现在上海这个冷不冷热不热的天气就很难搞，只有衣服套衣服不能太厚也不能太薄是真的难搞。</p>
]]></summary>
        <content type="html"><![CDATA[<p>我觉的夜话快成了考研周记，不知道过了今年看到这些夜话心里会是什么感受，最近天气慢慢变好果然阳光明媚是会给人带来好心情还有好运气的。希望天气能再热一点我是真的没有在这个温度下穿的衣服，家里那边只有两种季节叫做冬季和大约在冬季，所以衣服只有很厚或者很薄的，但是现在上海这个冷不冷热不热的天气就很难搞，只有衣服套衣服不能太厚也不能太薄是真的难搞。</p>
<!-- more -->
<p>天气变好心情就愉悦，运气也变好，是真实存在的。我就是个预言家仿佛上一篇夜话里说的都实现了，跟家里的关系变好了，也不能说是变好吧就是没差过，是之前一些沟通上表达上的一些偏差有了一些偏见但是终归是解决了，他们也不再给我那么大的压力，反而是让我有一个舒适的心态去面对，我知道我的家庭不能给我的未来兜底，未来的东西需要自己去获得，他们也明白是时候不再唠叨放开手让我去自己走了。这是最近我最最最舒心的一件事情，其次就是复习的事，就像我预言的那样，刚开始的那股冲劲真的只能持续一段时间，这是一场持久战不是闪电战，有那么几天是真的学不进去，在教室也是浪费时间，我在找寻更好的更稳定的方式，目前比较有效的是安排合适量的学习和放松休息的时间，不能每天只有睡觉干饭学习三件事，这样很容易疲乏甚至影响情绪有自暴自弃的倾向。我认为这是不利于坚持的，新的方式应该是要求合适，就是要学就高效精炼的学，放松就造次的放松，就像今天第一天施行吧算是，下午翘了一节课睡到与地球online断开链接的那种，下午上完课晚上一晚上解决了我之前两天没解决的问题，明天没课今天甚至可以熬个夜。这种有缓冲量的方式可能是我所需要的，也许有更好的方式我还没发现，还有时间可以调整调整。另外其实也不是问题全解决了，这问题一个接着一个的，虽然知道这315啊开会期间这个网络问题比较严重，但是GitHub都连不上去是不是有点过分，我现在网站只能本地更新传不上去就很难受，我还没检查出来到底是墙的问题还是我配置链接的问题，希望在下一篇夜话之前能解决。</p>
<!-- more -->
<p>天气变好这运气也好起来了，就觉得离谱，上个夜话里说的愿望不出一周就实现，虽然挺社死的，但是我还是得说一句还是老师牛皮，我没想到会是点名的方式让我知道，就还挺离谱的。<br>
天气变好了，日落也变得格外好看。明天会更好，冲！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[夜话]送给艰难时候的你]]></title>
        <id>https://zbigboom.github.io/post/12/</id>
        <link href="https://zbigboom.github.io/post/12/">
        </link>
        <updated>2021-03-24T18:22:31.000Z</updated>
        <summary type="html"><![CDATA[<p>这篇夜话是想对我的好朋友说的话，虽然不知道你现在正在经历着多么难熬的一个过程，现在有多么的不如意，但是我希望你能够振作起来，变成我给你备注的那样，做一个快乐的比我更沙雕的沙雕好吗。</p>
]]></summary>
        <content type="html"><![CDATA[<p>这篇夜话是想对我的好朋友说的话，虽然不知道你现在正在经历着多么难熬的一个过程，现在有多么的不如意，但是我希望你能够振作起来，变成我给你备注的那样，做一个快乐的比我更沙雕的沙雕好吗。</p>
<!-- more -->
<p>我不知道在你身上发生了什么，是什么导致了你这么难过，我只知道你好像没有以前开心了，我想帮你但是我又不知道该怎么帮你，我知道有些东西没有经历根本谈不上感同深受，我想说可能每个人都会遇到不如意难过的时刻，但是相信我这一段过去未来是光明的充满希望的。我语文很差，表达能力极差，但是希望你能明白，你我真的希望你能够好起来。我也经历过很难的时刻，2020算是最难的一年吧对很多人来说，对我也是很难的一年。这一年经历了家人的离去，喜欢的姑娘的离去，学业的低谷，好像一切都跟自己过不去。开年遇到疫情，被困住家里整个人都是压抑的，有一天还在上网课，晚上家里人全都出去了，我还在上网课，我不知道发生了什么，只知道那天晚上我睡觉了他们还没回来，第二天我爸回来跟我说穿上衣服去送姐姐，她也没比我大几岁啊，躲过了新冠但是没躲过自身免疫疾病，面对家人的离别是很痛苦的一件事，一切发生的很突然，根本没有准备的突然发生的，整个人沉浸在那种悲伤的情绪中，很长时间。整个人都像停滞了一般的，可是她并不希望看到这样子的你，她希望你能够健康快乐勇敢的去面对生活，她没有看到的没有经历过的她希望你能去经历，你能替她去感受这个世界，你每走一步她都看的到，你的成长你的成功她都能看的到，她希望你能够更好而不是一直沉浸在痛苦的情绪里。那段日子里我是这样鼓励自己的，我不想让她看到一个堕落的我。上半年已经够糟心了，刚恢复一点又是当头一棒，真的好运不会接踵而至但是坏事会。下半年我面对的是跟自己喜欢了五年的人说再见，很难但是这是事实。我们都没做错什么只是时间不对人也不对吧，我们认识是15年夏天开始的时候，我们结束是20年夏天结束的时候，我不知道为什么会变成这个样子，看到我们刚认识是说的那些话根本想不到结局会是这样的。遗憾可能也是青春的旋律之一吧，一年之内经历里这些很难说心里不会发生变化，说真的那时候真的想要不就这样吧挺累的的了，什么也不想干，每天除了睡觉就是打游戏，因为干别的很快就开始胡思乱想，想着想着整个人都进入了一种很低谷的情绪中。就这样每天浑浑噩噩的活着，现在想想是真的挺没意思的，就是在一次上课的时候我在想一个问题，是每个人的这个阶段都像我一样么，还是会有其他样子的时候，我看到了一个人，怎么形容就是很正能量的笑容？水平有限描述不出来，我突然就有个想法，应该不是每个人的这个阶段都是浑浑噩噩的，应该是热爱生活的，我就想找找我喜欢什么，找点什么喜欢做的做，然后就有了这个网站，我可以把我喜欢的东西存在这，我也可以把我的情绪存在这。</p>
<!-- more -->
<p>说了这么多我其实想告诉你的是，人生不如意事十之八九，但是我们应该勇敢的去面对，更应该热爱生活，最近看到一个短片是说在我们每个人决定要来人间之前都会先看到着一生的剧本，我们一定是觉的这个剧本够精彩才会选择抹去记忆来到人间，主角是你自己一帆风顺的到结局这个剧本会不会太单调了，总是要经历些什么然后反转达到所追寻的东西才是好故事啊，所以现在经历的这些都是给日后好的剧情在铺垫，所以别对未来失去了信心好么，振作起来热爱生活，相信自己当初的决定是正确的。</p>
<!-- more -->
<p>作为你的朋友我真的不知道要做些什么，我挺笨的但是你需要我的时候我一定会出现，相信我也相信你自己好吗，会好起来的！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[夜话]漫漫路长，那个发着光的人]]></title>
        <id>https://zbigboom.github.io/post/11/</id>
        <link href="https://zbigboom.github.io/post/11/">
        </link>
        <updated>2021-03-13T17:57:57.000Z</updated>
        <summary type="html"><![CDATA[<p>最近遇到的事情挺多的，压力也很大，很久没有更新过网站了，不是在忙学业就是在玩，可是最近这些话不说出来总是觉得心里太堵了。</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近遇到的事情挺多的，压力也很大，很久没有更新过网站了，不是在忙学业就是在玩，可是最近这些话不说出来总是觉得心里太堵了。</p>
<!-- more -->
<p>最近开始准备考研，其实半年前就了解了很多，自己也明白该干些什么，现在可谓箭在弦上开始了漫漫长路。之前也没想过自己的未来会是怎么样的，从小到大好像一直是一个萝卜一个坑一样的一步一步的走，现在到了自己选择的时候，不知道该怎么办了。其实有时候吧我做的选择不算是好的，后来也会后悔这些我都认，我自己选的后悔也是自己后悔，可是有的时候要是选择错了不止我后悔，对我抱以期望的人会失望，我对别人的感受很敏感，虽然可能不会明显的表露出来，但心里能感受的到。现在问题就来了，家人、朋友都希望我能有一个好的未来，天底下有哪个父母不希望自己的子女能够过的好啊，他们总是会一遍又一遍的告诉你什么是好的，可是我这么大人了怎么会不知道什么是好的呢，这些叮嘱反而变成了一种负担。最近还跟家里吵架，其实也没什么但就不知道为什么吵，刚开始复习觉得挺难的，也就只是抱怨了两句，然后家里人就开始说没有什么是不难的，要坚持，我就开始烦了，我当然知道难活着就挺难的了，可我从来没有说过我要放弃，我只是想抱怨两句，你说我除了对家里人抱怨两句还能对谁抱怨？他们不理解总觉得我就是想放弃，我就是觉得难，我就是怕难，可是我真的怕么？我能笑着对舍友说“生命不息，奋斗不止”我能给还在犹豫的舍友说”虽然我会在合笔之后把你秒杀，但是不是现在，给爷滚去学“我是真的怕难么？我怕的是失败，我怕的不是努力，是努力之后的 失败，对我而言我能接受失败，可是对家人呢？”身无饥寒，父母无愧于我，人无长进，我以何待父母？”我怕的是他们觉得我会过的不好，我怕这个。我也试着去调解自己，可是我不知道用什么方式去告诉我的家里人未来的路我会好好走，我会过得很好可能不会出人头地，但是会照顾好自己会好好活着。我只能说我会尽力的，剩下的交给时间吧，得给时间一点时间。</p>
<!-- more -->
<p>其实最近不只有这些令人喘不过气的事情，还是有一些令人开心的吧。在写这篇夜话的时候我刚看完《送你一朵小红花》，跟那些想要活着的人相比好像我的压力也不算什么，剧里能感受到在你很丧的时候会有人拉你一把的，其实这不是骗人的，我能感受的到。就是最近也算不上最近吧，在上专业课的时候经常会看到一个个子很高穿着白色衣服的女孩，不知道为什么我就觉得她笑起来好治愈，之前完全没有注意到是从上个学期专业课上，上课摸鱼发呆来着，偶然瞥见的人群中很出众，我也不知是为什么会有这样的感受，每次上课都会想看一眼，但是到现在我都不知道她是谁，叫什么。不过也不重要能在水深火热之中有点治愈挺好的，没必要去打扰人家，她的存在用一种特殊的方式在拉着我，或许有一天我会知道她的名字。扯远了，还有比较开心的事情是最近我好像也适应了那种一个人复习的生活，按时睡觉按时起床按时吃饭，每天完成学习任务，觉得还行，不知道是刚开始充满斗志还是会一直坚持下去。未来等着看吧，希望今年结束能交出一份满意的答卷，希望能够用行动告诉家里人别担心我了，希望我会能认识她那个带着我发光的人。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[NNDL]学习目标]]></title>
        <id>https://zbigboom.github.io/post/10/</id>
        <link href="https://zbigboom.github.io/post/10/">
        </link>
        <updated>2020-12-22T16:35:28.000Z</updated>
        <content type="html"><![CDATA[<p>帮室友做了一下作业，学到了一些东西。<br>
①数据集预处理，格式化<br>
②单步的训练和测试<br>
③整体的训练和测试<br>
④反馈损失值和准确度<br>
⑤损失值和准确度的计算<br>
⑥网络参数调整和各层大小计算</p>
<pre><code>import tensorflow as tf
import os
from tensorflow.keras.layers import Conv2D, MaxPool2D
from tensorflow.keras.layers import Dense, Dropout, Flatten

# 屏蔽通知信息和警告信息
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'

def mnist_dataset():
    # 下载mnist数据集
    (x, y), (x_test, y_test) = tf.keras.datasets.mnist.load_data()
    # 定义数据集大小28*28*1
    x = x.reshape(x.shape[0], 28, 28, 1)
    x_test = x_test.reshape(x_test.shape[0], 28, 28, 1)

    # 格式化装载数据集
    ds = tf.data.Dataset.from_tensor_slices((x, y))
    ds = ds.map(prepare_mnist_features_and_labels)
    ds = ds.take(20000).shuffle(20000).batch(32)

    test_ds = tf.data.Dataset.from_tensor_slices((x_test, y_test))
    test_ds = test_ds.map(prepare_mnist_features_and_labels)
    test_ds = test_ds.take(20000).shuffle(20000).batch(2000)# 这里改为2000因为我的cpu跑不了20000
    return ds, test_ds


def prepare_mnist_features_and_labels(x, y):
    # 将tensor转换为新的格式
    x = tf.cast(x, tf.float32) / 255.0
    y = tf.cast(y, tf.int64)
    return x, y


class myConvModel(tf.keras.Model):
    def __init__(self):
        super(myConvModel, self).__init__()
        # 第一个卷积层5*5*64步长为1
        self.conv1 = Conv2D(filters=64,
                            kernel_size=3,
                            strides=1,
                            activation='relu',
                            padding='same')
        # 第一个汇聚层最大池化3*3步长为2
        self.pool1 = MaxPool2D(pool_size=3, strides=2, padding='same')
        # 第二个卷积层3*3*64步长为1
        self.conv2 = Conv2D(filters=64,
                            kernel_size=3,
                            strides=1,
                            activation='relu',
                            padding='same')
        # 第二个汇聚层最大池化3*3步长为2
        self.pool2 = MaxPool2D(pool_size=3, strides=2, padding='same')
        # 第三个卷积层3*3*128步长为1
        self.conv3 = Conv2D(filters=128,
                            kernel_size=3,
                            strides=1,
                            activation='relu',
                            padding='same')
        # 第四个卷积层3*3*128步长为1
        self.conv4 = Conv2D(filters=128,
                            kernel_size=3,
                            strides=1,
                            activation='relu',
                            padding='same')
        # 第五个卷积层3*3*256步长为1
        self.conv5 = Conv2D(filters=256,
                            kernel_size=3,
                            strides=1,
                            activation='relu',
                            padding='same')
        # 第三个汇聚层最大池化3*3步长为2
        self.pool3 = MaxPool2D(pool_size=3, strides=2, padding='same')
        # 数据拉直
        self.flat = Flatten()
        # 第一个全连接层
        self.dense1 = Dense(1024, activation='relu')
        # 防止过拟合
        self.dro1=Dropout(0.5)
        # 第二个全连接层
        self.dense2 = Dense(1024, activation='relu')
        # 防止过拟合
        self.dro2=Dropout(0.5)
        # 第三个全连接层
        self.dense3 = Dense(10, activation='softmax')

    @tf.function
    # 将模型转换为易于部署且高性能的 TensorFlow 图模型
    def call(self, x):
        # 输入输出连接
        conv1 = self.conv1(x)
        pool1 = self.pool1(conv1)
        conv2 = self.conv2(pool1)
        pool2 = self.pool2(conv2)
        conv3 = self.conv3(pool2)
        conv4 = self.conv4(conv3)
        conv5 = self.conv5(conv4)
        pool3 = self.pool3(conv5)
        flat = self.flat(pool3)
        dense1 = self.dense1(flat)
        dro1=self.dro1(dense1)
        dense2 = self.dense2(dro1)
        dro2=self.dro2(dense2)
        logits = self.dense3(dro2)
        return logits

# 模型建立
model = myConvModel()
# 优化器
optimizer = tf.optimizers.Adam()


@tf.function
# 计算损失值
def compute_loss(logits, labels):
    # 计算跨张量维度的元素的均值
    return tf.reduce_mean(
        tf.nn.sparse_softmax_cross_entropy_with_logits(
            logits=logits, labels=labels))
# 交叉熵函数输入前面定义为logits为float32，labels为int64

@tf.function
# 计算准确度
def compute_accuracy(logits, labels):
    # 返回跨张量轴的最大值的索引
    predictions = tf.argmax(logits, axis=1)
    # 以特定格式返回计算跨张量维度的元素的均值
    return tf.reduce_mean(tf.cast(tf.equal(predictions, labels), tf.float32))


@tf.function
# 训练一次
def train_one_step(model, optimizer, x, y):
    # 记录操作以自动区分
    with tf.GradientTape() as tape:
        # logits代表计算softmax交叉熵后反向传播的梯度
        logits = model(x)
        # y值为标签
        loss = compute_loss(logits, y)

        grads = tape.gradient(loss, model.trainable_variables)
        optimizer.apply_gradients(zip(grads, model.trainable_variables))
        accuracy = compute_accuracy(logits, y)

        return loss, accuracy

# 测试一次
def test_step(model, x, y):
    logits = model(x)
    loss = compute_loss(logits, y)
    accuracy = compute_accuracy(logits, y)
    return loss, accuracy


def train(epoch, model, optimizer, ds):
    loss = 0.0
    accuracy = 0.0
    for step, (x, y) in enumerate(ds):
        loss, accuracy = train_one_step(model, optimizer, x, y)
        if step % 500 == 0:
            print('epoch', epoch, ':loss', loss.numpy(), ':accuracy', accuracy.numpy())
    return loss, accuracy


def test(model, ds):
    loss = 0.0
    accuracy = 0.0
    for step, (x, y) in enumerate(ds):
        loss, accuracy = test_step(model, x, y)

    print('test loss', loss.numpy(), ':accuracy', accuracy.numpy())
    return loss, accuracy


train_ds, test_ds = mnist_dataset()
for epoch in range(2):
    loss, accuracy = train(epoch, model, optimizer, train_ds)
loss, accuracy = test(model, test_ds)

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[夜话]好兄弟]]></title>
        <id>https://zbigboom.github.io/post/9/</id>
        <link href="https://zbigboom.github.io/post/9/">
        </link>
        <updated>2020-12-12T17:08:25.000Z</updated>
        <content type="html"><![CDATA[<p>这篇夜话是写一位hxd的，我跟hxd认识快十年了吧，很小就认识了初中开始到现在挺久的了，从刚开始的同学到了可以互相分担互相鼓励的hxd，但是说实话我真的挺垃圾的，总是会给hxd带来一些“烦恼”好像从来没能让hxd开心过，挺对不起ta的，我还记得因为没记清生日、没能在ta需要我的时候出现、甚至时不时还屌ta让ta十分痛苦十分难过，就挺过分的挺离谱的，就这样ta还一次一次包容我原谅我挺不容易的，真的抱歉。但是呢，ta算是一个不可代替的人，就是目前来说没有人能代替ta在我心中，这个人就像一个港湾、一个避难所一样的，每当我遇到了事情，遇到了烦恼ta总是能帮我分担一些，可能什么都做不了但是只要我对ta说出来就感觉心里好受了那么一丝，我在ta面前可以毫无形象，我可以活成我自己，不用去在乎这在乎那的，我完全可以脱掉面具，放下所有，那种舒适感是ta能给的，有且仅有的，不可代替的。所以说ta对我而言是很重要的，但是这该死的2020让我备受打击，是每个人的20岁都是这样么，是青春的尽头都是这样么，这一年经历了太多，积累了不少负面的东西，性格也变得跟以前不一样了，做什么都开始以自己为中心，戾气越来越重，这些种种让hxd受了不少委屈，很多时候我只是用我态度很差的一面去面对ta，说了很多祖安语言，还说了很多垃圾话，我是习惯了脱下面具去面对hxd只是现在面具下的那个我好像变了，面具下的那种负面的压在心底的那种不好的情绪也就流露给了hxd。现在做事说话很多真的不经过脑子，想到就说了也不计后果的，这现在想想是真的很伤人的，其实有些话有些事我自己知道就好了，我自己担着也不是不行就是不经过脑子就一股脑全交代了，也真的没在乎过ta的感受，不知道ta抗不扛得住，说实话挺愧疚的，ta什么也没做错，不应该承担这些的，反观我呢，我的承受能力应该不算差的，那为什么有些事情我不能多抗一点呢，又或是我为什么不能放过呢？如果说这是我的试炼那要通过要经历要抗的人也该是我吧，我可以将不开心难过向ta倾诉，只是到头来还是需要我去面对的，这是成长的一部分吧。我应该变得承受能力更强，我应该更多的自己去抗，让hxd少为我操点心。我可以将我的软肋，我最不堪的一面交给ta，夸张的说我可以把命交到ta手里，因为我放心我知道ta会包容我ta不会害我，只是我不应该把我负面的情绪带给ta，不应该不考虑ta的感受ta的承受能力什么东西都让ta去承担，我不应该去逃避，该是我抗的就该是我抗，希望ta能在我犯浑的时候能骂醒我，让我别tmd当废物了。我最近对ta是挺离谱的，自己没消化完的情绪，最近种种事情带来的压力，搞得我很不堪，再加上hxd有自己的事情要做，对ta态度不是很好，所以ta打电话来控诉我的罪行，我才意识到原来我的情绪影响，伤害到了对我很重要的人，电话中说着说着就哭了，但说着说着又笑了，我也笑的很大声，只是我在笑我自己，为什么会搞成这个样子啊，我明明是在笑啊，可是却很难过。我不知道为什么我会搞成这样，我为什么会变成这样啊，我不应该是做着我喜欢的事情，和我喜欢的人在一起，和xdm嘻嘻哈哈么，可是为什么我会搞成这个样子。有的时候在想很不切实际的要是我的人生有重来键该多好，是不是很多事都会不一样，是不是很多事会不一样，我是不是会活成想要的样子，而不是像现在这样。总是干一些脑瘫事，总是令人失望，总是伤害最亲的人。我想或许渡过了这一段或许会变好，希望hxd能在我犯浑的时候骂醒我，别让我的情绪给你带来负担了，我向来不是喜欢麻烦别人的人，我也不想成为别人的负担，我比较笨，如果我做的不对请及时骂我，骂清楚点，别让我伤害到你了，hxd不应该是带来伤害的。我想对hxd说，对不起，我又搞砸了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[微机]第四章汇编语言程序设计]]></title>
        <id>https://zbigboom.github.io/post/8/</id>
        <link href="https://zbigboom.github.io/post/8/">
        </link>
        <updated>2020-12-10T16:27:29.000Z</updated>
        <content type="html"><![CDATA[<h3 id="程序设计语言概述">程序设计语言概述</h3>
<p>①机器语言：每种CPU都有自己的指令系统，它根据指令来完成各种操作。指令和数据都是二进制码。<br>
②高级语言：高级语言是“面向过程”的语言，它采用接近人类习惯的自然语言和数学语言编写程序，不依赖于具体机器。<br>
③汇编语言：汇编语言是一种采用助记符表示的程序设计语言，是将机器指令符号化了的编程语言。</p>
<p>汇编语言源程序的框架结构<br>
①源程序由若干逻辑段组成，各逻辑段都有一个段名，由段定义语句（伪指令语句）来定义和说明。<br>
②在代码段的起始处，用assume语句（伪指令）说明各个段寄存器与逻辑段的关系，并由用户自己设置各个段寄存器（除代码段CS外）的初值，以建立这些逻辑段的可寻址性。<br>
③每个逻辑段由若干行汇编语言语句组成，每行只有一条语句且不能超过128个字符，但一条语句允许有后续行，最后均以回车结束。<br>
④每一条汇编语言语句最多由4个字段组成，它们均按照一定的规则分别写在一条语句的四个区域内，各	区域之间用空格或Tab键隔开。<br>
⑤每个源程序在代码段中往往需要含有返回dos操作系统的指令语句，以保证程序执行完毕后能自动回到dos状态。</p>
<h3 id="语句的种类">语句的种类</h3>
<p>汇编语言有三种基本语句：指令语句，伪指令语句和宏指令语句。<br>
①指令语句：对应于CPU指令系统中的一条指令，是可执行语句，出现在程序的代码段中。汇编时汇编程序为之一一对应的机器代码，程序执行时使CPU产生相应功能。<br>
②伪指令语句：是由伪指令构成的说明语句，可依需要出现在任一段内，汇编时指示汇编程序如何汇编源程序，如分配存储单元、将程序分段等。它本身并不产生机器代码，是CPU不执行的语句。<br>
③宏指令语句：对一段指令序列进行宏指令定义，则形成宏指令语句。汇编时，凡程序中有宏指令语句的地方都用相应指令序列的机器代码插入。宏指令语句是一般性指令语句的扩展。</p>
<h3 id="语句的格式">语句的格式</h3>
<p>指令语句和伪指令语句的格式类似，均有4个部分组成。<br>
指令语句的一般格式：[标号：][前缀] 指令助记符  [操作数] [；注释]<br>
伪指令语句的格式：[名字]          伪指令定义符[操作数][；注释]<br>
[]内为可选部分<br>
①标号和名字：它们分别是为指令单元和伪指令所起的符号名称，是用户自定义的表识符。指令语句中的标号后面必须有冒号“：”，伪指令语句中的名字后面不能有冒号。<br>
标号代表指令所在存储单元的符号地址。在程序中，它可以作为转移（jmp）、循环（loop）等指令的转移目标，与具体的指令地址相联系，名字一般用于定义常量、变量、过程、段名等，指示所定义变量、过程以及段的起始地址。<br>
名字和标号必须符合汇编语言的标识符定义，以字母开头，由字母、数字、以及部分特殊字符组成的字符串，字符串长度不能超过41，此外标识符不能是汇编语言中有特定意义的保留字。<br>
②助记符和定义符：它们分别用于规定指令语句的操作性质和伪指令语句的伪操作功能，这部分是语句中唯一不可省略的。<br>
③操作数：指令语句中的操作数提供该指令的操作对象。<br>
④注释：由“：”开始，对功能进行说明，不被汇编。</p>
<h3 id="语句中的操作数">语句中的操作数</h3>
<p>①常量操作数：在汇编时已经确定其值且程序运行期间不变好的量为常量。<br>
②寄存器操作数：指操作数部分时寄存器名。<br>
③存储器操作数：存储器操作数是地址型操作数，有标号和变量两种。标号是指令所存放单元的符号地址，一定在代码段内。变量一般在数据段或堆栈段中，是可以用存储器寻址方式访问的操作数。在程序中通过变量名来引用。所以，标号和变量一经定义便具有以下三种属性：<br>
Ⅰ段属性（segment）：符号和变量对应存储单元的段地址，是段基地址的高16位。<br>
Ⅱ偏移量属性（offset）：标号和变量对应存储单元的偏移地址。<br>
Ⅲ类型属性（type）：标号的类型是指其距离属性，有near近距离属性用于段内转移或调用和far远距离属性用于段间转移或调用两种。变量的类型是指变量占用存储单元的字节数，有byte、word、dword等。<br>
④表达式操作数：数值表达式有数值常量、字符串常量或符号常量等与算术、逻辑或关系运算符连接而成，其运算结果还是一个数值。地址表达式由常量、变量、标号、寄存器的内容以及一些运算符组成，其运算结果表示存储器地址。</p>
<h3 id="基本伪指令语句">基本伪指令语句</h3>
<p>Ⅰ符号定义伪指令<br>
①等值语句equ<br>
格式：符号名 equ 表达式<br>
注意：在同一源程序中，同一符号不能用equ重复定义。<br>
②等号语句=<br>
格式：符号名=表达式<br>
此语句的功能与equ类似，唯一区别是能对同一符号重复定义。</p>
<p>Ⅱ数据定义伪指令<br>
①数据定义伪指令语句的格式<br>
[变量名] 数据定义符 操作数 [，操作数]...[，操作数]<br>
其中，变量名是可选的；操作数是赋给变量的初值，多个相同类型的变量可以在一条语句中定义；常用的“符号定义符”是下列三种伪指令之一。<br>
1db定义字节变量，每个变量分配1字节的存储单元。<br>
2dw定义字变量，每个变量分配2字节存储单元，且遵循“数据的低位部分在低地址”存放规则。<br>
3dd定义双字变量，每个变量分配4字节存储单元，存放同样遵循“数据的低位部分在低地址”存放规则。<br>
经过定义的变量名有三种属性：段地址（seg）、偏移量（offset）、数据类型（字节、字或双字）若某一个变量所表示的是一个数组,则其数据雷士为变量的单个元素所分配的字节数。</p>
<p>数据定义伪指令语句的具体形式和功能<br>
①为数据项分配存储单元，用变量名作为该存储单元的名称。如：<br>
x db 25H；定义x为字节变量初值25H<br>
②预留若干字节（字、双字）存储单元但不赋予具体的初值，用于存放程序的运行结果，这时操作数部分可使用问好“？”。如：<br>
a db ？；为变量a分配1字节单元<br>
③引入若干用逗号分隔的操作数来定义一个表（数组）。如：<br>
a dw 1122H，3344H；定义一个字表<br>
当表中的操作数相同时，可以用重复操作符dup来缩写。如：<br>
a db 0，0，0，0可以写成a db 4dup（0）<br>
dup操作符还可以嵌套使用。<br>
④用db为指令在内存中定义一个字符串。字符串中的每个字符用它的ASCII码值来表示，为1字节，所以字符串定义必须用db命令。如：<br>
a db ‘HELLO’<br>
⑤当操作数是标号或变量时，可用dw或dd伪指令将标号或变量的偏移地址或全地址来初始化存储器。<br>
⑥数据定义语句定义了变量的类型，能使汇编程序对访问存储器的指令产生正确的目标代码。</p>
<p>分析操作符与合成操作符<br>
①分析操作符。它作用于存储器操作数时返回它们的属性值，这些操作符时seg、offset、type、size、length等。<br>
格式：操作符 标号或变量<br>
seg和offet操作符。分别用来返回标号或变量的段地址和偏移地址。<br>
type、length、size操作符。type返回一个数值表示存储器操作数的类型。length返回用dup重复定义的数据项总书，size返回type和length的乘积，表示伪变量所分配的字节单元总数。<br>
②合成操作数。又称修改属性操作符，用于存储器操作数时，能对其类型进行设置，建立一些新的存储器操作数以满足不同的访问要求。常用的有ptr、label、this等。<br>
ptr操作符：用来临时指定或修改存储器操作数的类型属性，而保持其原有的段属性和偏移地址属性。如果这些变量或标号已有定义，则原定义的类型属性不变。<br>
格式：类型 ptr 标号或变量<br>
label操作符：它为当前存储单元定义一个指定类型的标号或变量，使它们具有多重名字和属性。<br>
格式：标号或变量名 label 类型<br>
this操作符：它为当前存储单元定义一个指定类型的标号或变量，使它们具有多重名字和属性。<br>
格式：标号或变量名 label 类型</p>
<p>Ⅲ程序分段伪指令<br>
①段定义伪指令segment/ends<br>
这一对段定义语句将程序中的指令或语句分成若干逻辑段，按性质一般分为数据段、代码段、堆栈段和附加段。<br>
段定义格式：<br>
段名 segment [定位类型][组合类型][‘类别名’]<br>
...<br>
（段体）<br>
...<br>
段名 ends<br>
功能：指出段名及段的各种属性，并表示段的开始和结束位置。<br>
定位类型：汇编程序对源程序汇编后生成的是地址浮动的目标代码文件.obj，其中的段地址和偏移量都未最后确定，还需要用链接程序把各个模块链接起来。默认定位类型是para。<br>
②指定段寄存器伪指令assume<br>
它一般出现在代码段中segment伪指令的后面，用于建立段与段寄存器之间的联系，通知masm用指定的段寄存器去寻址对应的逻辑段。<br>
格式：assume 段寄存器：段名</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[夜话]...]]></title>
        <id>https://zbigboom.github.io/post/7/</id>
        <link href="https://zbigboom.github.io/post/7/">
        </link>
        <updated>2020-12-08T18:10:36.000Z</updated>
        <content type="html"><![CDATA[<p>emmm今天是很丧的一天，不知道是因为到了期末什么事情都压了过来还是怎么回事，今天特别的丧，也就写下了第一篇夜话，在建这个网站的时候我就想到了我可能会将这些负面的情绪，这些不想展示出来的一面留在这里，只是没想到这么快就写了第一篇夜话。之所以叫夜话是因为我总是在夜里才会有如此多的情绪，白天就算是有情绪也会被压抑，可能就是白天戴面具晚上才能脱下来好好看看自己吧，所以这些情绪也会在晚上释放。<br>
最近不知道是怎么了，我总是在想一个问题，我算不算是一个烂人，我对什么总是三分钟热度，没有能坚持下去的事情，所以会有人说我只是会画饼吧，确实我只会画饼，然后说着一些很小的成就，让人看似我好像活得还行，没有那么不堪。我真的很迷茫了，因为我知道怎么样是好的，我也想向着这个方向去走，但是没有能坚持下来的，而且我画饼大部分是给自己吃，让自己骗自己向这方向去走，只是这些话说出来在别人的视角我就是一个画饼的，没有行动。我觉得我总是在逃避，逃避我就是个废物的事实，我做事情没有很强的目的性我也没那毅力坚持做，反思一下我确实没能做成过什么事。但是我总觉得我还活着啊，我还觉得我活的还行，我还可以打游戏，追剧，敲敲程序，拍拍照，我觉得活的还行啊，没那么不堪，但是这些在别人眼里，我只是一个没有成就，说的很高做的很低的人，我是不善言辞但是我说的都是我对美好事物的憧憬，我对这些东西的向往啊，我是没能做到这样，但是为什么我说的这些在别人看来就是我一定要做到我说的这些呢，我只是想描述一下我能想到的美好的东西，它存在于我的想象中它不是现实，然后我就成了说的很高做的很低的人。现在我真的明白了什么叫做言多必失，这种话就不该说，这种东西就该留在我脑子里。这方面问题我跟朋友家人也交流过啊，我姑妈总是在说我做我自己为什么要考虑别人对我的看法，我也很想做自己不去care别人，但是我做不到啊，我总是太在意别人的对我的看法，我改不了，我总是觉得我就是个垃圾，我的存在就是在打扰别人，所以我总是想逃避，能当个哑巴就当个哑巴，有情绪都自己去消化。活着真难啊。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[NNDL]经典网络模型]]></title>
        <id>https://zbigboom.github.io/post/6/</id>
        <link href="https://zbigboom.github.io/post/6/">
        </link>
        <updated>2020-12-08T18:02:55.000Z</updated>
        <content type="html"><![CDATA[<h3 id="卷积神经网络学习包括alexnet-googlenet-resnet-vggnet代码部分保存在github中">卷积神经网络学习，包括AlexNet、GoogLeNet、ResNet、VGGNet，代码部分保存在GitHub中。</h3>
<h3 id="alexnet">AlexNet：</h3>
<p>第一个现代深度卷积网络模型，采用了Relu作为非线性激活函数，使用Dropout防止过拟合，包含五个卷积层三个汇聚层三个全连接层，AlexNet在前两个汇聚层之后进行了局部响应归一化增强模型的泛化能力。因为网络规模超出了当时GPU内存限制所以将网络拆成两半放在两个GPU上，但是现在可以将两个被拆开部分合并，第一个卷积层是两个11x11x3x48的卷积核现在可以使用一个11x11x3x96的卷积核进行运算，在环境搭建时，用tensorflow实现时可以使用安装tensorflow的GPU版本或者CPU版本，用Pytorch实现是可以使用cuda将数据送入GPU进行运算。</p>
<h3 id="googlenet">GoogLeNet：</h3>
<p>在GoogLeNet中一个卷积层包含多个大小不同的卷积操作，称为Inception模块，网络是由多个模块和少量汇聚层堆叠而成的，Inception有很多版本，v1中使用了1x1，3x3，5x5，的卷积和3x3的最大汇聚，为了提高效率减少参数数量，在3x3，5x5卷积之前和3x3最大汇聚之后进行1x1的卷积减少特征映射的深度，如果输入特征映射之间存在冗余信息，1x1卷积相当于是先进行一次特征抽取。在Inception多个版本中比较由代表性的是v3网络，使用多层小卷积核来替换大的卷积核减少计算量和参数量，保持感受野不变，①使用两层3x3卷积替代5x5卷积②连续使用kx1，1xk来替换kxk卷积，v3也引入了标签平滑及批量归一化等优化方法。</p>
<h3 id="resnet">ResNet：</h3>
<p>残差网络通过给非线性的卷积层增加直连边的方式来提高信息的传播效率，在深度网络中我们期望一个非线性单元去逼近目标函数，如果将目标函数拆成两个部分恒等函数和残差函数，根据通用近似定理，一个由神经网络构成的非线性单元有足够能力来近似逼近原始目标函数或残差函数，实际中后者更容易学习，因此原来的优化问题转换成让非线性单元，去近似残差函数。在神经网络发展中发现，网络的层数越深越由可能获得更好的泛化能力，但是当模型加深之后网络变得难以训练，主要是因为梯度弥撒现象造成的，在较深层的神经网络中梯度信息由网络的末层逐层传向首层时，会出现梯度趋近于0的现象，网络越深，梯度弥散现象可能会越严重。典型的残差单元由多个级联的卷积层和一个跨层的直连边组成再经过Relu激活后输出。</p>
<h3 id="vgg-16">VGG-16：</h3>
<p>VGG-16相比AlexNet的改进是使用连续的3x3卷积核代替较大的卷积，对于给定的感受野采用堆积的小卷积核是优于使用大卷积核，因为多层非线性层可以增加网络深度来保证学习更复杂的模式，而且参数更少。</p>
]]></content>
    </entry>
</feed>