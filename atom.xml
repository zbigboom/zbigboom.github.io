<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zbigboom.github.io</id>
    <title>ZBigBoom</title>
    <updated>2020-12-08T18:00:25.455Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zbigboom.github.io"/>
    <link rel="self" href="https://zbigboom.github.io/atom.xml"/>
    <subtitle>我的世界</subtitle>
    <logo>https://zbigboom.github.io/images/avatar.png</logo>
    <icon>https://zbigboom.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, ZBigBoom</rights>
    <entry>
        <title type="html"><![CDATA[[微机]第三章指令系统]]></title>
        <id>https://zbigboom.github.io/post/5/</id>
        <link href="https://zbigboom.github.io/post/5/">
        </link>
        <updated>2020-12-08T10:33:00.000Z</updated>
        <content type="html"><![CDATA[<h3 id="指令格式">指令格式</h3>
<p>一般格式如下：<br>
指令助记符  操作数列表 ；注释<br>
指令助记符是指令的名称，对应机器指令中的操作码部分，操作数可以有多个，因指令不同而不同，按序排列并用“，”分开。“；”之后是注释部分，不影响指令操作。</p>
<h3 id="有效地址ea">有效地址EA</h3>
<p>指令中的操作数有三个可能存放位置<br>
①操作数包含在指令中，即指令的操作数部分就是操作数本身，这种操作数叫做立即数，对应的寻址方式称为立即寻址。</p>
<p>②操作数存放在CPU的某个内部寄存器中，称为寄存器操作数，这时指令的操作数部分是CPU内部寄存器的编码，对应寻址方式称为寄存器寻址。</p>
<p>③操作数在内存的数据区中，称为存储器操作数，这时指令的操作数部分给出操作数的存储地址，指令执行时需要根据该地址找到需要的操作数，这种寻址方式称为存储器寻址。<br>
组成有效地址EA的基本部分可以包括：基址寄存器内容；变址寄存器内容；位移量；比例因子。</p>
<center>EA=（基址寄存器）+（变址寄存器x比例因子）+位移量</center>
<p>基址寄存器：BX，BP<br>
变址寄存器：SI，DI<br>
比例因子：1<br>
位移量：0，8，16（位）</p>
<h3 id="各种寻址方式">各种寻址方式</h3>
<p>Ⅰ立即寻址<br>
立即寻址方式下，操作数作为立即数包含在指令中，它紧跟在操作码之后与其一起存放在代码段区域。<br>
Ⅱ寄存器寻址<br>
寄存器寻址方式的操作数存放在指令规定的8位、16位CPU内部寄存器中。<br>
这是CPU内部操作，不需要使用访问总线周期，所以指令的执行速度较快。<br>
Ⅲ存储器寻址方式<br>
存储器寻址时，操作数是在存储区中，指令的操作数部分指出此操作数的有效地址EA，而段地址在默认的或段超越前缀指定的段寄存器中。根据EA的不同组合方式，存储器寻址方式又可以分为以下：</p>
<p>①直接寻址：直接寻址是一种最简单的存储器寻址方式。在这种寻址方式下，指令中操作数部分直接给出操作数的有效地址EA，与操作码一起放在代码段中。操作数一般在数据段DS中。如果要对除DS段之外的其他段中的数据寻址，应在指令中增加段超越前缀指出段寄存器名。<br>
例如：<br>
mov  AX，[2000H]；将DS段中2000H和2001H单元内容送入AL和AH<br>
mov AX，ES：[2000H]；将ES段中2000H和2001H单元内容送入AL和AH</p>
<p>②寄存器间接寻址：操作数在存储区内，操作数的有效地址EA在指令指定的寄存器中，即EA=（寄存器）<br>
以SI、DI、BX间接寻址，则默认操作数在数据段中<br>
mov  AX，[SI]；默认DS为段地址<br>
以BP间接寻址，则默认操作数在堆栈段中<br>
mov  AX，[BP]；默认为SS为段地址<br>
若操作数不在上述规定的默认段则必须在指令的相应操作数前加上段超越前缀。<br>
mov  CX，DS：[BP]；DS是该指令的段超越前缀<br>
直接寻址中有效地址EA来自指令自身，相当于一个常量。寄存器间接寻址中有效地址EA来自寄存器，寄存器的内容由前面的指令确定，相当于一个变量。</p>
<p>③基址寻址：这种寻址方式下，操作数的有效地址EA=（基址寄存器）+位移量，式中位移量在指令中给出并与操作码一起存放在代码段中。<br>
BP和BX作为基址寄存器。默认情况下，BX以DS作为段寄存器，BP以SS作为段寄存器，可以段超越，位移量是8位或16位。</p>
<p>④变址寻址：变址寻址方式下，有效地址EA=（变址寄存器）+位移量，它的指令格式及寻址过程与基址寻址相同，区别仅在于将基址寄存器改成变址寄存器。<br>
SI和DI作为变址寄存器，且默认DS作为段寄存器。基址或变址寻址非常适于对一维数组元素进行检索操作，常用为ui连表示数组起始地址，基址或变址寄存器表示数组元素的可变下标。</p>
<p>⑤比例变址寻址：这种寻址方式只适合32位寻址的情况。（了解）</p>
<p>⑥基址加变址寻址：这种寻址方式中，操作数的有效地址EA=（基址寄存器）+（变址寄存器）。<br>
基址、变址寄存器的使用规定和段寄存器的默认规定与前面所述相同，但要注意当一种寻址方式中的基址、变址寄存器默认的段寄存器不同时，一般由基址寄存器来决定默认哪一个段寄存器作短地址。若在指令中规定了段超越则可用其他段寄存器作为短地址。例如：<br>
mov  AX，[BX+SI]；或写成mov  AX，[BX][SI]，BX决定默认DS为段寄存器<br>
基址加变址寻址适合检索二维数组元素和双重循环等操作。<br>
⑦基址加比例变址寻址：这种寻址方式只适合32位寻址情况。（了解 ）</p>
<p>⑧带位移量的基址加变址寻址：这种寻址方式下，有效地址EA=（基址寄存器）+（变址寄存器）+位移量。<br>
基址、变址寄存器的使用规定和对段寄存器的默认规定与前面所述相同。例如：<br>
mov  AX，[BX+SI+MASK]；或写成mov  AX，MASK[BX][SI]<br>
带位移量的基址加变址寻址也适用于对二维数组操作，位移量即为数组起始地址。</p>
<p>⑨带位移量的基址加比例变址寻址：这种寻址适用于32位寻址情况。（了解）</p>
<h3 id="存储器寻址时的段约定">存储器寻址时的段约定</h3>
<table>
<thead>
<tr>
<th style="text-align:center">访问存储器类型</th>
<th style="text-align:center">默认段寄存器</th>
<th style="text-align:center">允许超越的段寄存器</th>
<th style="text-align:center">偏移地址寄存器</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">取指令</td>
<td style="text-align:center">CS</td>
<td style="text-align:center">无</td>
<td style="text-align:center">IP</td>
</tr>
<tr>
<td style="text-align:center">堆栈操作</td>
<td style="text-align:center">SS</td>
<td style="text-align:center">无</td>
<td style="text-align:center">SP</td>
</tr>
<tr>
<td style="text-align:center">源串数据访问</td>
<td style="text-align:center">DS</td>
<td style="text-align:center">CS、ES、SS</td>
<td style="text-align:center">SI</td>
</tr>
<tr>
<td style="text-align:center">目的串数据访问</td>
<td style="text-align:center">ES</td>
<td style="text-align:center">无</td>
<td style="text-align:center">DI</td>
</tr>
<tr>
<td style="text-align:center">通用数据访问</td>
<td style="text-align:center">DS</td>
<td style="text-align:center">CS、ES、SS</td>
<td style="text-align:center">偏移地址EA</td>
</tr>
<tr>
<td style="text-align:center">以BP、SP间接寻址指令</td>
<td style="text-align:center">SS</td>
<td style="text-align:center">CS、DS、ES</td>
<td style="text-align:center">偏移地址EA</td>
</tr>
</tbody>
</table>
<h3 id="cpu指令系统">CPU指令系统</h3>
<p>指令操作数符号说明</p>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">OPRD，OPRDN</td>
<td style="text-align:center">操作数；第N个操作数，如OPRD1，OPRD2</td>
</tr>
<tr>
<td style="text-align:center">DEST，SRC</td>
<td style="text-align:center">目的操作数，源操作数</td>
</tr>
<tr>
<td style="text-align:center">reg</td>
<td style="text-align:center">通用寄存器，长度可以是8位或16位</td>
</tr>
<tr>
<td style="text-align:center">reg8</td>
<td style="text-align:center">8位通用寄存器AH/AL/BH/BL/CH/CL/DH/DL</td>
</tr>
<tr>
<td style="text-align:center">reg16</td>
<td style="text-align:center">16位通用寄存器AX/BX/CX/DX/SI/DI/BP/SP</td>
</tr>
<tr>
<td style="text-align:center">Sreg</td>
<td style="text-align:center">段寄存器DS/CS/SS/ES</td>
</tr>
<tr>
<td style="text-align:center">mem</td>
<td style="text-align:center">存储器操作数，长度可以是8位或16位</td>
</tr>
<tr>
<td style="text-align:center">imm</td>
<td style="text-align:center">立即数，长度可以是8位或16位</td>
</tr>
</tbody>
</table>
<h3 id="数据传送类指令">数据传送类指令</h3>
<p>Ⅰ通用数据传送</p>
<table>
<thead>
<tr>
<th>指令功能</th>
<th>指令书写格式</th>
</tr>
</thead>
<tbody>
<tr>
<td>字节或字传送</td>
<td>mov 目标，源</td>
</tr>
<tr>
<td>字压入堆栈</td>
<td>push 源</td>
</tr>
<tr>
<td>字弹出堆栈</td>
<td>pop 目标</td>
</tr>
<tr>
<td>字节或字交换</td>
<td>xchg 目标，源</td>
</tr>
<tr>
<td>字节翻译</td>
<td>xlat</td>
</tr>
</tbody>
</table>
<p>①mov指令<br>
指令格式：mov OPRD1，OPRD2<br>
功能：将源操作数传送给目标操作数，即OPRD2-&gt;OPRD1，源操作数保持不变。<br>
注意：OPRD1和OPRD2的长度一致；立即数和段寄存器CS不能作为目标操作数；立即数不能直接传送到段寄存器；不允许在两个存储单元之间或在两个段寄存器之间直接传送数据；将立即数传送到存储单元时，必须显式说明存储器操作数的宽度类型。</p>
<p>②堆栈操作指令push/pop<br>
指令格式：push OPERD2；pop OPRD1<br>
功能：push指令使SP-2-&gt;SP，然后将16位源操作数压入堆栈。入栈时高字节存放在高地址，源操作数可以是通用寄存器、段寄存器和存储器。<br>
pop指令使SP+2-&gt;SP，弹出时低地址字节送低字节，使SP指向新的栈顶，目标操作数可以是通用寄存器、段寄存器（CS除外）或存储器。</p>
<p>③交换指令xchg<br>
指令格式：xchg OPRD1，OPRD2<br>
功能：将长度相同的源操作数与目标操作数进行交换。<br>
注意：段寄存器和立即数不能作为操作数；不能在两个存储单元之间之间交换数据。</p>
<p>④查表转换指令xlat（或称换码指令）<br>
指令格式：xlat或xlat OPRD<br>
功能：完成1字节的查表转换。它将数据段中偏移地址位（BX+AL）的存储单元的内容送入AL寄存器，即DS：[BX+AL]-&gt;AL。<br>
xlat指令对于一些无规律的代码转换特别方便，使用时在数据段建立一个长度小于256字节的表格，表的首地址置于BX中AL中存放查找对象在表中的下标，指令执行后，所查找的对象存于AL中，BX内容保持不变。</p>
<p>Ⅱ地址传送</p>
<table>
<thead>
<tr>
<th>指令功能</th>
<th>指令书写格式</th>
</tr>
</thead>
<tbody>
<tr>
<td>装入有效地址</td>
<td>lea 目标，源</td>
</tr>
<tr>
<td>装入逻辑地址</td>
<td>lds 目标，源</td>
</tr>
<tr>
<td>装入逻辑地址</td>
<td>les 目标，源</td>
</tr>
</tbody>
</table>
<p>①有效地址传送指令lea<br>
指令格式：lea OPRD1，OPRD2<br>
功能：将源操作数在当前段内的有效地址（即偏移地址）传送至目标操作数。<br>
注意：这条指令同mov指令的区别是，mov指令传送操作数的内容，而lea传送的是操作数的存储地址。</p>
<p>②地址指针传送指令lds和les<br>
指令格式：lds/les OPRD1，OPRD2<br>
功能：这两条指令的功能类似，都是将源操作数偏移地址的双字存储单元中的第一个字的内容送入指定的16位通用寄存器，第二个字的内容传送给段寄存器DS或ES。</p>
<p>Ⅲ标志位传送</p>
<table>
<thead>
<tr>
<th>指令功能</th>
<th>指令书写格式</th>
</tr>
</thead>
<tbody>
<tr>
<td>将标志寄存器FR低字节装入AH</td>
<td>lahf</td>
</tr>
<tr>
<td>将AH内容装入FR低字节</td>
<td>sahf</td>
</tr>
<tr>
<td>将FR内容压入堆栈</td>
<td>pushf</td>
</tr>
<tr>
<td>从堆栈弹出FR内容</td>
<td>popf</td>
</tr>
</tbody>
</table>
<p>①标志寄存器读/写指令lahf/sahf<br>
功能：lahf用于用于将标志寄存器的低字节（含SF、ZF、AF、PF、CF）读出后送给AH寄存器，本条指令本身不影响标志位。sahf与lahf的操作相反。</p>
<p>②标志寄存器入栈/出栈指令pushf/popf<br>
pushf指令的执行过程同push指令，只是将标志寄存器FR的内容压入堆栈，popf则是将当前栈顶的一个字传送给标志寄存器FR，同时修改栈顶指针SP。</p>
<p>ⅣI/O数据传送</p>
<table>
<thead>
<tr>
<th>指令功能</th>
<th>指令书写格式</th>
</tr>
</thead>
<tbody>
<tr>
<td>输入字节或字</td>
<td>in 累加器，端口</td>
</tr>
<tr>
<td>输出字节或字</td>
<td>out 端口，累加器</td>
</tr>
</tbody>
</table>
<p>输入/输出数据传送指令in/out<br>
指令格式：in OPRD1，OPRD2<br>
功能：这组指令专门用于在AL或AX寄存器与I/O端口之间传送数据。</p>
<h3 id="算术运算类指令">算术运算类指令</h3>
<p>Ⅰ二进制加减法类算术运算指令</p>
<table>
<thead>
<tr>
<th>指令功能</th>
<th>指令书写格式</th>
</tr>
</thead>
<tbody>
<tr>
<td>加法</td>
<td>add 目标，源</td>
</tr>
<tr>
<td>带进位加法</td>
<td>adc 目标，源</td>
</tr>
<tr>
<td>加1</td>
<td>inc 目标</td>
</tr>
<tr>
<td>减法</td>
<td>sub 目标，源</td>
</tr>
<tr>
<td>带借位减法</td>
<td>sbb 目标，源</td>
</tr>
<tr>
<td>减1</td>
<td>dec 目标</td>
</tr>
<tr>
<td>取负</td>
<td>neg 目标</td>
</tr>
<tr>
<td>比较</td>
<td>cmp 目标，源</td>
</tr>
</tbody>
</table>
<p>①加/减法指令add/sub<br>
指令格式：add/sub OPRD1，OPRD2<br>
功能：完成两个操作数的加/减运算，结果送入目标操作数，即OPRD1±OPRD2-&gt;OPRD1<br>
注意：要求源操作数和目标操作数同为带符号数或无符号数，且长度相等。源操作数可以是寄存器、存储器、或立即数，目标操作数只能是寄存器或存储器，且两个操作数不能同时为存储器。运算影响全部状态标志位。</p>
<p>②带进/借位的加/减法指令adc/sbb<br>
指令格式：adc/sbb OPRD1，OPRD2<br>
功能：adc/sbb指令常与add/sub配合，用于两个或两个以上的多进度数的运算，除了加法操作时加上的进位或减法时的借位，它们同add/sub指令的使用注意事项和对标志位的影响情况相同。</p>
<p>③增量和减量指令inc/dec<br>
指令格式：inc/dec OPRD<br>
功能：inc/dec是单操作数指令，完成对指定操作数的加一减一，然后返回运算结果。<br>
主要是用于调整地址指针和计数器，所以不影响CF标志。</p>
<p>④求补指令neg<br>
指令格式：neg OPRD<br>
功能：对操作数求补，即用0减去操作数，再把结果送回操作数，求补运算也可以表达将操作数按位取反加一，neg指令影响所有状态标志位。</p>
<p>⑤比较指令cmp<br>
指令格式：cmp OPRD1，OPRD2<br>
功能：cmp将计算OPRD1-OPRD2，但运算结果不返回OPRD1，即cmp指令与sub执行同样的操作，同样影响标志位，只是不改变操作数本身。参加比较的源操作数可以是立即数、寄存器或存储器操作数，目标操作数只能是寄存器或存储器操作数。<br>
如果是两个无符号数比较，若CF=1则OPRD1 &lt; OPRD2；若CF=0，则OPRD1 &gt; OPRD2<br>
如果是两个带符号数比较，SF异或OF=1则OPRD1 &lt; OPRD2；SF异或OF=0则OPRD1 &gt; OPRD2<br>
无论操作数是否带符号ZF=1则OPRD1=OPRD2。</p>
<p>Ⅱ二进制乘/除法指令</p>
<table>
<thead>
<tr>
<th>指令功能</th>
<th>指令书写格式</th>
</tr>
</thead>
<tbody>
<tr>
<td>不带符号乘法</td>
<td>mul</td>
</tr>
<tr>
<td>带符号乘法</td>
<td>imul</td>
</tr>
<tr>
<td>不带符号除法</td>
<td>div</td>
</tr>
<tr>
<td>带符号除法</td>
<td>idiv</td>
</tr>
</tbody>
</table>
<p>①乘法指令mul/imul<br>
指令格式：mul/imul OPRD<br>
功能：mul/imul指令分别用于实现无符号数的乘法和有符号数的乘法，他们都只有一个源操作数，源操作数可以是寄存器或存储器，而目标操作数隐含规定在累加器中。<br>
若OPRD为字节则ALxOPRD乘积存于AX；若OPRD为字则AXxOPRD乘积的高16位存于DX低16位存于AX中。由于乘法指令保留了2倍于原来操作数的存储空间，因而不会出现溢出现象。</p>
<p>②除法指令div/idiv<br>
指令格式：div/idiv OPRD<br>
对于字节除法，被除数在AX中，除数即OPRD（字节）商在AL中，余数在AH中；对于字除法，被除数高位在DX中，低位在AX中，除数OPRD（字），商在AX中，余数在DX中。若商超过存放它的寄存器容量，则会引起0型中断，且商和余数为不定值。<br>
注意：在除法运算中，要求被除数的长度为除数长度的2倍，若被除数和除数是具有相同位数的字节或字，这是需要将被除数扩展为字或双字，且大小符号不变，然后再相除。</p>
<p>Ⅲ符号扩展指令</p>
<table>
<thead>
<tr>
<th>指令功能</th>
<th>指令书写格式</th>
</tr>
</thead>
<tbody>
<tr>
<td>字节转换字</td>
<td>cbw</td>
</tr>
<tr>
<td>字转换双字</td>
<td>cwd</td>
</tr>
</tbody>
</table>
<p>符号扩展指令cbw/cwd<br>
指令格式cbw/cwd<br>
功能：cbw/cwd分别用于将有符号操作数从字节转换成字或从字转换为双字，操作数隐含规定在累加器中。<br>
cbw将AL中的字节符号数的符号扩展到AH；cwd将AX中的子符号数的符号扩展到DX中。<br>
注意：对无符号数，可采用直接使高位置‘0’的方法进行扩展。</p>
<p>ⅣBCD（十进制）运算调整指令</p>
<table>
<thead>
<tr>
<th>指令功能</th>
<th>指令书写格式</th>
</tr>
</thead>
<tbody>
<tr>
<td>非压缩BCD数的加法调整</td>
<td>aaa</td>
</tr>
<tr>
<td>压缩BCD数的加法调整</td>
<td>daa</td>
</tr>
<tr>
<td>非压缩BCD数的减法调整</td>
<td>aas</td>
</tr>
<tr>
<td>压缩BCD数的减法调整</td>
<td>das</td>
</tr>
<tr>
<td>非压缩BCD数的乘法调整</td>
<td>aam</td>
</tr>
<tr>
<td>非压缩BCD数的除法调整</td>
<td>aad</td>
</tr>
</tbody>
</table>
<p>①非压缩BCD数加/减法调整指令aaa/aas<br>
功能：aaa/aas用于将AL中的两个非压缩BCD数相加/减后的结果进行调整，以得到正确的非压缩BCD和/差，程序中它们紧跟在add/sub指令之后。</p>
<p>②压缩BCD数加/减法调整指令daa/das<br>
功能：用于将AL中两个压缩BCD数相加/减的结果进行校正，以得到正确的压缩BCD和/差。程序中它们紧跟在add/sub指令之后。</p>
<p>③非压缩BCD数乘/除法调整指令aam/aad<br>
功能：aam紧跟在mul指令之后，将AX中两个1位非压缩BCD数相乘的结果进行调整；aad在两个非压缩BCD数的除法运算之前，先调整AL和AH中的内容，再用div指令相除。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[微机]第二章8086微处理器]]></title>
        <id>https://zbigboom.github.io/post/4/</id>
        <link href="https://zbigboom.github.io/post/4/">
        </link>
        <updated>2020-12-02T13:20:07.000Z</updated>
        <content type="html"><![CDATA[<h3 id="8086cpu基本结构">8086CPU基本结构</h3>
<p>8086由两个独立的处理部件组成：执行部件EU和总线接口部件BIU。<br>
①执行机构EU：包括8个16位寄存器（通用寄存器AX、BX、CX、DX；指针寄存器SP、BP；变址寄存器SI、DI）算数逻辑部件ALU、标志寄存器FR、暂存寄存器和EU控制系统。<br>
②总线接口部件BIU：由4个段寄存器（CS、SS、DS、ES）指令指针IP、内部通信寄存器、指令队列、总线控制逻辑和地址加法器组成。</p>
<h3 id="特点">特点</h3>
<p>①取指令与执行指令重叠并行（指令流水线）。<br>
②段寄存器和储存器分段：8086有四个段寄存器，代码段寄存器CS、数据段寄存器DS、堆栈段寄存器SS、附加数据段寄存器ES。<br>
每个段的物理长度是64K。<br>
基于存储器的分段结构，在涉及储存器的地址时，必须分清是物理地址还是逻辑地址。CPU访问存储器时地址总线送出的是物理地址，编写程序时则采用逻辑地址，逻辑地址由短地址和偏移量组成。<br>
物理地址计算公式：</p>
<center>物理地址=段地址*16+偏移量</center>
<h3 id="寄存器配置">寄存器配置</h3>
<p>Ⅰ通用寄存器：8086有8个16位通用寄存器，8个通用寄存器分两组。<br>
第一组：AX、BX、CX、DX，他们又可以分成两个8位寄存器，当处理字节指令时，用8位寄存器，处理字指令时，用16位寄存器。<br>
特殊用法：BX寄存器在计算地址时用作基址寄存器；CX寄存器在操作指令中用作计数器；DX寄存器在某些I/O操作期间用来保存I/O端口地址。<br>
第二组：堆栈指针SP、基地址指针BP、源变址寄存器SI、目的变址寄存器DI，4个16位寄存器。<br>
这组寄存器的目的是：①算短指令代码的长度②在程序运行过程中，允许指令访问这样的存储单元，他们在段内的偏移量正是前面指令的计算结果③用于寄存偏移量，与段寄存器内容相加获得物理地址。<br>
Ⅱ段寄存器：见特点中段寄存器。<br>
Ⅲ指令指针IP：指令指针是一个16位寄存器，功能与程序计数器PC类似。IP总是包含下一条指令在当前代码段的偏移量（人话：IP在这个代码段内保存与下一条指令的偏移量）。</p>
<center>下一条指令的物理地址=CS*16+IP或CS*10H+IP</center>
<p>Ⅳ状态标志寄存器FR：FR标志寄存器是16位寄存器，但只使用其中9位。<br>
①CF进位标志：当进行加减运算时，若最高位产生进位或借位时CF=1。<br>
②PF奇偶标志：若运算结果低八位中含有1的个数为偶数时PF=1，此标志一般用来检测数据传输中是否发生错误。<br>
③AF辅助进位标志：低四位向高四位有进位或借位，则AF=1，此标志用于校正BCD编码的十进制算数指令操作。<br>
④ZF零标志：若运算结果为0，则ZF=1。<br>
⑤SF符号标志：对于带符号数，若运算结果最高位为1为负数则SF=1。<br>
⑥OF溢出标志：当进行带符号数补码运算时，结果超出了机器所能表示的数值范围，产生了“溢出”则OF=1。<br>
⑦IF中断允许标志：该标志用于允许或禁止CPU响应外部中断，由程序控制。若IF=1则CPU可以响应外部可屏蔽中断的中断请求。<br>
⑧DF方向标志：用于串操作，由程序控制，若DF=1，表示执行串操作时，从高地址开始向低地址逐个处理，即串地址自动减量。<br>
⑨TF陷阱标志：该标志是为了调试程序而设置的。若TF=1，表示CPU以单步方式执行程序，即CPU每执行完一条指令，就自动产生一次内部中断。</p>
<h3 id="8086引脚及功能">8086引脚及功能</h3>
<p>8086有40条引脚（PIN）双列直插式（DIP）封装。<br>
引脚太多仅列出部分重点，剩余查询教材P56。<br>
NMI：非屏蔽中断请求，输入，上升沿有效。NMI是上升沿触发的非屏蔽中断请求输入信号，它不能通过软件进行屏蔽，只要引脚上出现一个从低到高的电脉冲，就能使CPU现行指令结束，立即进入中断响应，转去执行NMI中断处理。<br>
INTR：可屏蔽中断请求，输入，高电平有效。INTR是电平触发，CPU在每条指令的最后一个时钟周期对INTR信号线采样，若发现INTR引脚信号为高电平，同时CPU内部中断允许标志IF=1时，CPU就进入中断响应周期，CPU响应中断时，暂停正在执行的主程序，从数据总线读取中断类型码，根据中断类型码从存储器的中断向量表查询相应的中断服务程序的入口地址，转到该地址去执行中断服务程序，在中断结束之后再返回主程序的断点处继续执行程序。<br>
INTA：中断响应信号，输出，三态，低电平有效，在CPU响应外部中断请求后，发给请求中断的设备回答信号。<br>
ALE：地址锁存允许信号，输出，高电平有效。当地址/数据总线分时传送地址信息时，ALE用作把地址信号锁存入8282/8283或74LS373锁存器的锁存控制信号。<br>
DEN：数据允许，输出，三态，低电平有效，在单CPU系统中如果8286/8287作为数据总线的双向驱动器，则用DEN作为驱动器的选通信号。<br>
DT/R：数据发送/接受控制，输出，三态，在单CPU系统中，如果用8286/8287作为数据总线的双向驱动，这是要用DT/R控制数据传送方向。<br>
WR：写信号，输出，三态，低电平有效，WR信号有效时，表示CPU正在执行写存储器或写I/O口操作。<br>
RD：读信号，输出，三态，低电平有效，RD信号有效时，表示CPU在读存储器或I/O口的数据。</p>
<h3 id="cpu系统总线及其操作">CPU系统总线及其操作</h3>
<p>①总线请求和仲裁阶段。需要使用总线的主模块提出请求，由总线仲裁机构确定把下一个传输周期的总线使用全分配给哪一个请求源。<br>
②寻址阶段。去的使用权的主模块通过总线发出本次要访问的从模块的存储器地址或I/O端口地址，启动参与本次传输的从模块。<br>
③数据传输阶段。主模块和从模块进行数据交换。在主模块发出的控制信号作用下，数据由源模块发出，经数据总线传送到目的模块。<br>
④结束阶段。主、从模块的有关信息从系统总线上撤除，让出总线，以便其他模块能使用。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[微机]第一章计算机基础]]></title>
        <id>https://zbigboom.github.io/post/3/</id>
        <link href="https://zbigboom.github.io/post/3/">
        </link>
        <updated>2020-12-01T07:48:09.000Z</updated>
        <content type="html"><![CDATA[<p>计算机在本质上只能识别0，1表示的二进制数码。一个数在机器中的表示形式称为机器数。</p>
<h3 id="机器数有以下特点">机器数有以下特点</h3>
<p>①机器数的正负号都是数值化的。（一般首位为符号位，0表示正数1表示负数）<br>
②机器数所表示的数的范围收机器字长的限制。</p>
<h3 id="机器字长">机器字长</h3>
<p>①位（bit）：是计算机所能表示的最小数据单位，它只有0，1两种状态。<br>
②字节（Byte）：是一个8位二进制数。<br>
③字（Word）：一般指16位二进制数，也就是两个字节。<br>
④字长（Word Length）：指处理器的二进制位数，是衡量计算机性能的一个重要标志，字长越长精度越高性能越强。</p>
<h3 id="进制简写">进制简写</h3>
<p>二进制-B    八进制-O或Q   十进制-D   十六进制-H</p>
<h3 id="数的表示方法">数的表示方法</h3>
<p>①原码：是数值部分为绝对值，加上0，1表示的“+”“-”的机器数。<br>
②反码：正数的反码与原码相同，负数的反码符号位不变为1，其余位取反。<br>
③补码：正数的补码与原码相同，负数的补码先求反码之后在反码末位加1就是负数的补码。<br>
小结：<br>
①有符号数的三种编码最高位都是符号位。<br>
②正数的三种编码相同。<br>
③8位二进制原码反码补码的数值表示范围不同，分别是-127<sub>+127，-127</sub>+127，-128~+127。<br>
补码的运算：<br>
（x+y）补=2^n+（x+y）=（x）补+（y）补<br>
（x-y）补=2^n+（x-y）=（x）补+（-y）补<br>
（-y）补可以通过连同符号位在内一起取反后+1（求补）<br>
注意：两个数相加之后可能会出现负数的情况，这种情况为“溢出”。<br>
小结：<br>
①补码运算时运算数为补码结果也是补码，根据要求可能会有编码转换。<br>
②在进行减法运算时变为加负数的运算，简化硬件设计。<br>
③运算时Ⅰ 符号位与数值位一起参加运算Ⅱ符号位产生的进位可舍弃Ⅲ要保证运算结果不超过补码所能表示的数的最大范围，否则会出现“溢出”错误。<br>
④无符号数和有符号数的加法运算可用同一电路完成</p>
<h3 id="定点数和浮点数">定点数和浮点数</h3>
<p>定点表示法时小数位置在数中固定不变<br>
①定点纯小数：把小数点固定在最高数值位左边。（小数点本身不占位只是约定固定小数点的位置）<br>
②定点纯整数：把小数点固定在最低数值位右边。<br>
浮点数：把一个数通过改变小数点的位置表示成2的p次幂和绝对值小于1的数s相乘的形式。</p>
<center>N=(2^p)*S</center>
N称为浮点数或实数，S是N的尾数
<p><strong>例 1011.1101 B=（0.10111101 B）<em>（2^4）= 0.10111101</em>(2^100) B</strong><br>
先转化位小数*2^p的形式，然后将p转化为二进制的形式，根据格式要求在不同数位填入数值即得到想要的浮点数。</p>
<h3 id="bcd码">BCD码</h3>
<p>BCD码只是将每个十进制数用四位二进制数表示而且每组四位二进制数之间仍然是逢十进一的关系。<br>
正确的BCD码运算必须对二进制数的运算结果进行调整，使之符合十进制数的运算和进位规律，这种调整称为十进制调整，其规则如下：<br>
①若两个BCD数相加的结果大于9（1001）则应加6（0110）修正。<br>
②若两个BCD数相加的结果在本位上并没有大于9（1001）但是产生了进位，相当于十进制数运算大于等于16则也应加6（0110）修正。</p>
<h3 id="了解bcd码在计算机中有两种表示方式">（了解）BCD码在计算机中有两种表示方式</h3>
<p>①使用1字节表示两位十进制数，称压缩BCD码。<br>
②用8位二进制数表示一位十进制数。<br>
前者占内存少，利用率高；后者占内存多，但其运算及调整相对简单。</p>
<h3 id="了解计算机中非数据信息表示">（了解）计算机中非数据信息表示</h3>
<p>西文：采用ASCII码，这是一种8位代码，最高位可用于奇偶校验，仅用7位码代表字符信息，共有128个字符，其中34种功能码，94种符号。<br>
中文：一个汉字用2字节（256*256=65536种状态）编码，同时每字节最高位区分汉字编码和ASCII码，又称汉字交换码。<br>
图 声 像信息：模拟信息经过采样、量化、编码转换成数字信息，采用二进制编码表示。</p>
<h3 id="微型计算机结构">微型计算机结构</h3>
<p>计算机结构大体分为两类：哈佛结构和冯·诺依曼结构<br>
哈佛结构（了解）：程序和数据空间独立的体系结构，不仅采用不同的存储模块，而且通过各自的总线进行访问。优点是可以并行访问程序和数据从而提升了运行效率，缺点是硬件结构复杂，对输入输出设备的连接和处理要求高。<br>
冯·诺依曼结构：程序和数据共享存储空间和总线，缺点是将分时实现程序和数据的访问，影响了数据处理的速度，但是优点明显，结构简单易于实现。<br>
冯·诺依曼结构的基本思想：<br>
①计算机应由运算器、控制器、存储器、输入输出设备五大部分组成。<br>
②存储器不但能存放数据，也能存放程序。计算机具有区分指令和数据的能力，而且数据和指令都以二进制数的形式存放。<br>
③将事先编好的程序放入存储器中，在指令计数器的控制下，自动高速运行。</p>
<h3 id="微型计算机的硬件">微型计算机的硬件</h3>
<p>分为五个部分：①微处理器（CPU）②内存储器（RAM、ROM）③总线（地址总线AB、数据总线DB、控制总线CB）④接口芯片（I/O接口）⑤输入/输出设备（外设，I/O）。<br>
Ⅰ微处理器（CPU）<br>
分为运算部分和控制部分<br>
①ALU算术逻辑单元：运算核心控制信号作用下完成加减乘除运算和与、或、非和异等逻辑运算。<br>
②ACC累加器：通用寄存器中的一个，它往往提供送入ALU的两个运算操作数中的一个和ALU配合密切。<br>
③RS通用寄存器组：用来加快运算和处理速度。访问寄存器比访问存储器快得多。<br>
④FR状态寄存器：记录计算机运行的某些重要状态，比如是否溢出、是否为零、是否为负等。<br>
⑤SP堆栈指针：用来指示栈顶，其初值由程序员设定。（堆栈是一组寄存器或指定存储器中的某一区域，堆栈中信息存入（Push）和弹出（Pop）过程显示货物堆放的过程，特先进后出（FILO））<br>
⑥PC程序计数器：指示当前要执行的指令地址码，程序中各条指令一般是按执行的顺序存放在存储器中，PC指向第一条指令所在地址编号，每取出一条指令后自动指向后续指令。<br>
⑦IR指令寄存器、ID指令译码器、PLA控制逻辑：这是政改革微处理器的指挥控制中心，它依据事先编好的程序依次从存储器中取出各条指令，放在指令寄存器中，通过指令译码，然后通过控制逻辑在确定的时间向确定的部分发出控制信号。<br>
Ⅱ内存储器<br>
内存储器中存放两类信息，一类是待处理的数据和运算结果，另一类是处理数据的程序。<br>
内存储器通常有两类：随机访问存储器RAM和只读存储器ROM，RAM可以随时写入内容亦可进行修改，ROM事先存储规定好的内容，只能将规定的内容读出，不能改写。<br>
Ⅲ总线<br>
①数据总线DB：用来传输数据，通常包括CPU和内存储器或输入输出设备之间交换数据的双向传输线路。<br>
②地址总线AB：用来传送地址。<br>
③控制总线CB：用来传送控制信号、时序信号和状态信息等，其中每根线的方向是一定的、单向的，但是作为整体，控制总线是双向的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[说明]]></title>
        <id>https://zbigboom.github.io/post/2/</id>
        <link href="https://zbigboom.github.io/post/2/">
        </link>
        <updated>2020-11-30T08:45:51.000Z</updated>
        <content type="html"><![CDATA[<p>这个网站是基于我的GitHub和Gridea完成的一个私人博客网站，所有的图片连接都是由Picgo和GitHub完成。但是有个很严重的问题，就是GitHub被墙这个事情，导致加载很慢而且图片不会显示，我查了很多资料解决的办法有：①电脑端可以通过改hosts的方法可以解决，具体操作百度，或者我的GitHub中NNDL库有写具体修改②这个是所有设备端都可以正常浏览的选项就是挂vpn出去看。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[初 · 心]]></title>
        <id>https://zbigboom.github.io/post/1/</id>
        <link href="https://zbigboom.github.io/post/1/">
        </link>
        <updated>2020-11-29T11:16:59.000Z</updated>
        <content type="html"><![CDATA[<p>这里写有我想要搞这样一个网站博客的初心。</p>
<p>①这也是比较重要的一个点吧，就是不知道从什么时候起，自己的学习能力开始急速下降，一个东西学了很久但是几乎没有什么收获，好像是从高中出来就不知道该怎么去学习了，再加上没有什么压力，自己也就变的很怠慢，结果是成绩很差，是时候做些改变不是么？突然有个想法就是做一份学习笔记，就像自己教自己那样的，施教的人是第一遍学习的我，我得要把知识学懂然后整理总结出来写成一份笔记，受教的人也是我是在复习的我，第二遍学习时可以根据第一遍学习的笔记，说不定还会有一些新的理解。这个想法是受到一个老朋友的启发，我觉得这种方式或许对我有用。另外是学习跟不上我觉得可能还有另外的一些原因吧，就是自己的懒惰，以前学习是有一个动力的目的性很强，但是这个目的性现在看来没有那么强烈了，所以做事也就怠慢了。</p>
<p>②另外想要做这样一个网站的原因是我想分享一些东西，我知道这个网站是不会有人去关注的，所以这些东西也就是自己分享给自己，给以后的自己看看现在的自己的生活和想法。这个网站不像是动态、朋友圈、微博这样的社交网站，这里算是我的秘密基地吧，我可以畅所欲言，我可以分享我很感兴趣的事情，也算是保存我记忆的一种方式吧，所以这个网站里不仅会有我的学习日记也会有一些我的日常分享，这些我不想给所有人看，我只想给未来的自己留下些什么。未来不会像以前那样了，突然的少了些东西，这份我最容易丢的东西就保存在这吧，未来的自己看到也不会迷茫了。<br>
<img src="https://raw.githubusercontent.com/zbigboom/Picgo/master/math.jpeg" alt="数学" loading="lazy"><br>
数学都是这样的道理，做人不也是这个道理么，累了没动力了停下来回头看看自己，然后继续冲下去不是么。</p>
]]></content>
    </entry>
</feed>