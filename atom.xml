<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zbigboom.github.io</id>
    <title>ZBigBoom</title>
    <updated>2020-12-01T16:33:24.790Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zbigboom.github.io"/>
    <link rel="self" href="https://zbigboom.github.io/atom.xml"/>
    <subtitle>我的世界</subtitle>
    <logo>https://zbigboom.github.io/images/avatar.png</logo>
    <icon>https://zbigboom.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, ZBigBoom</rights>
    <entry>
        <title type="html"><![CDATA[[微机]第一章计算机基础]]></title>
        <id>https://zbigboom.github.io/post/3/</id>
        <link href="https://zbigboom.github.io/post/3/">
        </link>
        <updated>2020-12-01T07:48:09.000Z</updated>
        <content type="html"><![CDATA[<p>计算机在本质上只能识别0，1表示的二进制数码。一个数在机器中的表示形式称为机器数。</p>
<h3 id="机器数有以下特点">机器数有以下特点</h3>
<p>①机器数的正负号都是数值化的。（一般首位为符号位，0表示正数1表示负数）<br>
②机器数所表示的数的范围收机器字长的限制。</p>
<h3 id="机器字长">机器字长</h3>
<p>①位（bit）：是计算机所能表示的最小数据单位，它只有0，1两种状态。<br>
②字节（Byte）：是一个8位二进制数。<br>
③字（Word）：一般指16位二进制数，也就是两个字节。<br>
④字长（Word Length）：指处理器的二进制位数，是衡量计算机性能的一个重要标志，字长越长精度越高性能越强。</p>
<h3 id="进制简写">进制简写</h3>
<p>二进制-B    八进制-O或Q   十进制-D   十六进制-H</p>
<h3 id="数的表示方法">数的表示方法</h3>
<p>①原码：是数值部分为绝对值，加上0，1表示的“+”“-”的机器数。<br>
②反码：正数的反码与原码相同，负数的反码符号位不变为1，其余位取反。<br>
③补码：正数的补码与原码相同，负数的补码先求反码之后在反码末位加1就是负数的补码。<br>
小结：<br>
①有符号数的三种编码最高位都是符号位。<br>
②正数的三种编码相同。<br>
③8位二进制原码反码补码的数值表示范围不同，分别是-127<sub>+127，-127</sub>+127，-128~+127。<br>
补码的运算：<br>
（x+y）补=2^n+（x+y）=（x）补+（y）补<br>
（x-y）补=2^n+（x-y）=（x）补+（-y）补<br>
（-y）补可以通过连同符号位在内一起取反后+1（求补）<br>
注意：两个数相加之后可能会出现负数的情况，这种情况为“溢出”。<br>
小结：<br>
①补码运算时运算数为补码结果也是补码，根据要求可能会有编码转换。<br>
②在进行减法运算时变为加负数的运算，简化硬件设计。<br>
③运算时Ⅰ 符号位与数值位一起参加运算Ⅱ符号位产生的进位可舍弃Ⅲ要保证运算结果不超过补码所能表示的数的最大范围，否则会出现“溢出”错误。<br>
④无符号数和有符号数的加法运算可用同一电路完成</p>
<h3 id="定点数和浮点数">定点数和浮点数</h3>
<p>定点表示法时小数位置在数中固定不变<br>
①定点纯小数：把小数点固定在最高数值位左边。（小数点本身不占位只是约定固定小数点的位置）<br>
②定点纯整数：把小数点固定在最低数值位右边。<br>
浮点数：把一个数通过改变小数点的位置表示成2的p次幂和绝对值小于1的数s相乘的形式。</p>
<center>N=(2^p)*S</center>
N称为浮点数或实数，S是N的尾数
**例 1011.1101 B=（0.10111101 B）*（2^4）= 0.10111101*(2^100) B**
先转化位小数*2^p的形式，然后将p转化为二进制的形式，根据格式要求在不同数位填入数值即得到想要的浮点数。
<h3 id="bcd码">BCD码</h3>
<p>BCD码只是将每个十进制数用四位二进制数表示而且每组四位二进制数之间仍然是逢十进一的关系。<br>
正确的BCD码运算必须对二进制数的运算结果进行调整，使之符合十进制数的运算和进位规律，这种调整称为十进制调整，其规则如下：<br>
①若两个BCD数相加的结果大于9（1001）则应加6（0110）修正。<br>
②若两个BCD数相加的结果在本位上并没有大于9（1001）但是产生了进位，相当于十进制数运算大于等于16则也应加6（0110）修正。</p>
<h3 id="了解bcd码在计算机中有两种表示方式">（了解）BCD码在计算机中有两种表示方式</h3>
<p>①使用1字节表示两位十进制数，称压缩BCD码。<br>
②用8位二进制数表示一位十进制数。<br>
前者占内存少，利用率高；后者占内存多，但其运算及调整相对简单。</p>
<h3 id="了解计算机中非数据信息表示">（了解）计算机中非数据信息表示</h3>
<p>西文：采用ASCII码，这是一种8位代码，最高位可用于奇偶校验，仅用7位码代表字符信息，共有128个字符，其中34种功能码，94种符号。<br>
中文：一个汉字用2字节（256*256=65536种状态）编码，同时每字节最高位区分汉字编码和ASCII码，又称汉字交换码。<br>
图 声 像信息：模拟信息经过采样、量化、编码转换成数字信息，采用二进制编码表示。</p>
<h3 id="微型计算机结构">微型计算机结构</h3>
<p>计算机结构大体分为两类：哈佛结构和冯·诺依曼结构<br>
哈佛结构（了解）：程序和数据空间独立的体系结构，不仅采用不同的存储模块，而且通过各自的总线进行访问。优点是可以并行访问程序和数据从而提升了运行效率，缺点是硬件结构复杂，对输入输出设备的连接和处理要求高。<br>
冯·诺依曼结构：程序和数据共享存储空间和总线，缺点是将分时实现程序和数据的访问，影响了数据处理的速度，但是优点明显，结构简单易于实现。<br>
冯·诺依曼结构的基本思想：<br>
①计算机应由运算器、控制器、存储器、输入输出设备五大部分组成。<br>
②存储器不但能存放数据，也能存放程序。计算机具有区分指令和数据的能力，而且数据和指令都以二进制数的形式存放。<br>
③将事先编好的程序放入存储器中，在指令计数器的控制下，自动高速运行。</p>
<h3 id="微型计算机的硬件">微型计算机的硬件</h3>
<p>分为五个部分：①微处理器（CPU）②内存储器（RAM、ROM）③总线（地址总线AB、数据总线DB、控制总线CB）④接口芯片（I/O接口）⑤输入/输出设备（外设，I/O）。<br>
Ⅰ微处理器（CPU）<br>
分为运算部分和控制部分<br>
①ALU算术逻辑单元：运算核心控制信号作用下完成加减乘除运算和与、或、非和异等逻辑运算。<br>
②ACC累加器：通用寄存器中的一个，它往往提供送入ALU的两个运算操作数中的一个和ALU配合密切。<br>
③RS通用寄存器组：用来加快运算和处理速度。访问寄存器比访问存储器快得多。<br>
④FR状态寄存器：记录计算机运行的某些重要状态，比如是否溢出、是否为零、是否为负等。<br>
⑤SP堆栈指针：用来指示栈顶，其初值由程序员设定。（堆栈是一组寄存器或指定存储器中的某一区域，堆栈中信息存入（Push）和弹出（Pop）过程显示货物堆放的过程，特先进后出（FILO））<br>
⑥PC程序计数器：指示当前要执行的指令地址码，程序中各条指令一般是按执行的顺序存放在存储器中，PC指向第一条指令所在地址编号，每取出一条指令后自动指向后续指令。<br>
⑦IR指令寄存器、ID指令译码器、PLA控制逻辑：这是政改革微处理器的指挥控制中心，它依据事先编好的程序依次从存储器中取出各条指令，放在指令寄存器中，通过指令译码，然后通过控制逻辑在确定的时间向确定的部分发出控制信号。<br>
Ⅱ内存储器<br>
内存储器中存放两类信息，一类是待处理的数据和运算结果，另一类是处理数据的程序。<br>
内存储器通常有两类：随机访问存储器RAM和只读存储器ROM，RAM可以随时写入内容亦可进行修改，ROM事先存储规定好的内容，只能将规定的内容读出，不能改写。<br>
Ⅲ总线<br>
①数据总线DB：用来传输数据，通常包括CPU和内存储器或输入输出设备之间交换数据的双向传输线路。<br>
②地址总线AB：用来传送地址。<br>
③控制总线CB：用来传送控制信号、时序信号和状态信息等，其中每根线的方向是一定的、单向的，但是作为整体，控制总线是双向的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[说明]]></title>
        <id>https://zbigboom.github.io/post/2/</id>
        <link href="https://zbigboom.github.io/post/2/">
        </link>
        <updated>2020-11-30T08:45:51.000Z</updated>
        <content type="html"><![CDATA[<p>这个网站是基于我的GitHub和Gridea完成的一个私人博客网站，所有的图片连接都是由Picgo和GitHub完成。但是有个很严重的问题，就是GitHub被墙这个事情，导致加载很慢而且图片不会显示，我查了很多资料解决的办法有：①电脑端可以通过改hosts的方法可以解决，具体操作百度，或者我的GitHub中NNDL库有写具体修改②这个是所有设备端都可以正常浏览的选项就是挂vpn出去看。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[初 · 心]]></title>
        <id>https://zbigboom.github.io/post/1/</id>
        <link href="https://zbigboom.github.io/post/1/">
        </link>
        <updated>2020-11-29T11:16:59.000Z</updated>
        <content type="html"><![CDATA[<p>这里写有我想要搞这样一个网站博客的初心。</p>
<p>①这也是比较重要的一个点吧，就是不知道从什么时候起，自己的学习能力开始急速下降，一个东西学了很久但是几乎没有什么收获，好像是从高中出来就不知道该怎么去学习了，再加上没有什么压力，自己也就变的很怠慢，结果是成绩很差，是时候做些改变不是么？突然有个想法就是做一份学习笔记，就像自己教自己那样的，施教的人是第一遍学习的我，我得要把知识学懂然后整理总结出来写成一份笔记，受教的人也是我是在复习的我，第二遍学习时可以根据第一遍学习的笔记，说不定还会有一些新的理解。这个想法是受到一个老朋友的启发，我觉得这种方式或许对我有用。另外是学习跟不上我觉得可能还有另外的一些原因吧，就是自己的懒惰，以前学习是有一个动力的目的性很强，但是这个目的性现在看来没有那么强烈了，所以做事也就怠慢了。</p>
<p>②另外想要做这样一个网站的原因是我想分享一些东西，我知道这个网站是不会有人去关注的，所以这些东西也就是自己分享给自己，给以后的自己看看现在的自己的生活和想法。这个网站不像是动态、朋友圈、微博这样的社交网站，这里算是我的秘密基地吧，我可以畅所欲言，我可以分享我很感兴趣的事情，也算是保存我记忆的一种方式吧，所以这个网站里不仅会有我的学习日记也会有一些我的日常分享，这些我不想给所有人看，我只想给未来的自己留下些什么。未来不会像以前那样了，突然的少了些东西，这份我最容易丢的东西就保存在这吧，未来的自己看到也不会迷茫了。<br>
<img src="https://raw.githubusercontent.com/zbigboom/Picgo/master/math.jpeg" alt="数学" loading="lazy"><br>
数学都是这样的道理，做人不也是这个道理么，累了没动力了停下来回头看看自己，然后继续冲下去不是么。</p>
]]></content>
    </entry>
</feed>